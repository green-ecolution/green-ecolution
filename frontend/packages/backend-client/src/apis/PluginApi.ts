/* tslint:disable */
/* eslint-disable */
/**
 * Green Space Management API
 * This is the API for the Green Ecolution Management System.
 *
 * The version of the OpenAPI document: develop
 * Contact: info@green-ecolution.de
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ClientToken,
  HTTPError,
  Plugin,
  PluginAuth,
  PluginListResponse,
  PluginRegisterRequest,
} from '../models/index';
import {
    ClientTokenFromJSON,
    ClientTokenToJSON,
    HTTPErrorFromJSON,
    HTTPErrorToJSON,
    PluginFromJSON,
    PluginToJSON,
    PluginAuthFromJSON,
    PluginAuthToJSON,
    PluginListResponseFromJSON,
    PluginListResponseToJSON,
    PluginRegisterRequestFromJSON,
    PluginRegisterRequestToJSON,
} from '../models/index';

export interface GetPluginInfoRequest {
    pluginSlug: string;
}

export interface PluginHeartbeatRequest {
    pluginSlug: string;
}

export interface RefreshPluginTokenRequest {
    pluginSlug: string;
    body: PluginAuth;
}

export interface RegisterPluginRequest {
    body: PluginRegisterRequest;
}

export interface UnregisterPluginRequest {
    pluginSlug: string;
}

/**
 * 
 */
export class PluginApi extends runtime.BaseAPI {

    /**
     * Retrieves detailed information about a specific registered plugin.
     * Get plugin info
     */
    async getPluginInfoRaw(requestParameters: GetPluginInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Plugin>> {
        if (requestParameters['pluginSlug'] == null) {
            throw new runtime.RequiredError(
                'pluginSlug',
                'Required parameter "pluginSlug" was null or undefined when calling getPluginInfo().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("Keycloak", []);
        }


        let urlPath = `/v1/plugin/{plugin_slug}`;
        urlPath = urlPath.replace(`{${"plugin_slug"}}`, encodeURIComponent(String(requestParameters['pluginSlug'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PluginFromJSON(jsonValue));
    }

    /**
     * Retrieves detailed information about a specific registered plugin.
     * Get plugin info
     */
    async getPluginInfo(requestParameters: GetPluginInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Plugin> {
        const response = await this.getPluginInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a list of all plugins currently registered with the system.
     * Get all registered plugins
     */
    async getPluginsListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PluginListResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("Keycloak", []);
        }


        let urlPath = `/v1/plugin`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PluginListResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves a list of all plugins currently registered with the system.
     * Get all registered plugins
     */
    async getPluginsList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PluginListResponse> {
        const response = await this.getPluginsListRaw(initOverrides);
        return await response.value();
    }

    /**
     * Sends a heartbeat signal to indicate the plugin is still active. Should be called periodically.
     * Plugin heartbeat
     */
    async pluginHeartbeatRaw(requestParameters: PluginHeartbeatRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['pluginSlug'] == null) {
            throw new runtime.RequiredError(
                'pluginSlug',
                'Required parameter "pluginSlug" was null or undefined when calling pluginHeartbeat().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("Keycloak", []);
        }


        let urlPath = `/v1/plugin/{plugin_slug}/heartbeat`;
        urlPath = urlPath.replace(`{${"plugin_slug"}}`, encodeURIComponent(String(requestParameters['pluginSlug'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Sends a heartbeat signal to indicate the plugin is still active. Should be called periodically.
     * Plugin heartbeat
     */
    async pluginHeartbeat(requestParameters: PluginHeartbeatRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.pluginHeartbeatRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Exchanges plugin credentials for a new access token. Use when the previous token has expired.
     * Refresh plugin token
     */
    async refreshPluginTokenRaw(requestParameters: RefreshPluginTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ClientToken>> {
        if (requestParameters['pluginSlug'] == null) {
            throw new runtime.RequiredError(
                'pluginSlug',
                'Required parameter "pluginSlug" was null or undefined when calling refreshPluginToken().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling refreshPluginToken().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/v1/plugin/{plugin_slug}/token/refresh`;
        urlPath = urlPath.replace(`{${"plugin_slug"}}`, encodeURIComponent(String(requestParameters['pluginSlug'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PluginAuthToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ClientTokenFromJSON(jsonValue));
    }

    /**
     * Exchanges plugin credentials for a new access token. Use when the previous token has expired.
     * Refresh plugin token
     */
    async refreshPluginToken(requestParameters: RefreshPluginTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ClientToken> {
        const response = await this.refreshPluginTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Registers a new plugin with the system. Returns authentication tokens for plugin API access.
     * Register a plugin
     */
    async registerPluginRaw(requestParameters: RegisterPluginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ClientToken>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling registerPlugin().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/v1/plugin`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PluginRegisterRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ClientTokenFromJSON(jsonValue));
    }

    /**
     * Registers a new plugin with the system. Returns authentication tokens for plugin API access.
     * Register a plugin
     */
    async registerPlugin(requestParameters: RegisterPluginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ClientToken> {
        const response = await this.registerPluginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Removes a plugin registration from the system. The plugin will no longer be able to access the API.
     * Unregister a plugin
     */
    async unregisterPluginRaw(requestParameters: UnregisterPluginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['pluginSlug'] == null) {
            throw new runtime.RequiredError(
                'pluginSlug',
                'Required parameter "pluginSlug" was null or undefined when calling unregisterPlugin().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("Keycloak", []);
        }


        let urlPath = `/v1/plugin/{plugin_slug}/unregister`;
        urlPath = urlPath.replace(`{${"plugin_slug"}}`, encodeURIComponent(String(requestParameters['pluginSlug'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Removes a plugin registration from the system. The plugin will no longer be able to access the API.
     * Unregister a plugin
     */
    async unregisterPlugin(requestParameters: UnregisterPluginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.unregisterPluginRaw(requestParameters, initOverrides);
    }

}
