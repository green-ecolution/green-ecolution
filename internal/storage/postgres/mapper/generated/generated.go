// Code generated by github.com/jmattheis/goverter, DO NOT EDIT.
//go:build !goverter

package generated

import (
	entities "github.com/green-ecolution/backend/internal/entities"
	sqlc "github.com/green-ecolution/backend/internal/storage/postgres/_sqlc"
	mapper "github.com/green-ecolution/backend/internal/storage/postgres/mapper"
	entities1 "github.com/green-ecolution/backend/internal/storage/postgres/sensor/entities"
	utils "github.com/green-ecolution/backend/internal/utils"
	"time"
)

type InternalRegionRepoMapperImpl struct{}

func (c *InternalRegionRepoMapperImpl) FromSql(source *sqlc.Region) *entities.Region {
	var pEntitiesRegion *entities.Region
	if source != nil {
		var entitiesRegion entities.Region
		entitiesRegion.ID = (*source).ID
		entitiesRegion.CreatedAt = utils.TimeToTime((*source).CreatedAt)
		entitiesRegion.UpdatedAt = utils.TimeToTime((*source).UpdatedAt)
		entitiesRegion.Name = (*source).Name
		pEntitiesRegion = &entitiesRegion
	}
	return pEntitiesRegion
}
func (c *InternalRegionRepoMapperImpl) FromSqlList(source []*sqlc.Region) []*entities.Region {
	var pEntitiesRegionList []*entities.Region
	if source != nil {
		pEntitiesRegionList = make([]*entities.Region, len(source))
		for i := 0; i < len(source); i++ {
			pEntitiesRegionList[i] = c.FromSql(source[i])
		}
	}
	return pEntitiesRegionList
}

type InternalSensorRepoMapperImpl struct{}

func (c *InternalSensorRepoMapperImpl) FromDomainSensorData(source *entities.MqttPayload) *entities1.MqttPayload {
	var pEntitiesMqttPayload *entities1.MqttPayload
	if source != nil {
		var entitiesMqttPayload entities1.MqttPayload
		entitiesMqttPayload.Device = (*source).Device
		entitiesMqttPayload.Battery = (*source).Battery
		entitiesMqttPayload.Humidity = (*source).Humidity
		entitiesMqttPayload.Temperature = (*source).Temperature
		if (*source).Watermarks != nil {
			entitiesMqttPayload.Watermarks = make([]entities1.Watermark, len((*source).Watermarks))
			for i := 0; i < len((*source).Watermarks); i++ {
				entitiesMqttPayload.Watermarks[i] = c.entitiesWatermarkToEntitiesWatermark((*source).Watermarks[i])
			}
		}
		pEntitiesMqttPayload = &entitiesMqttPayload
	}
	return pEntitiesMqttPayload
}
func (c *InternalSensorRepoMapperImpl) FromSql(source *sqlc.Sensor) (*entities.Sensor, error) {
	var pEntitiesSensor *entities.Sensor
	if source != nil {
		var entitiesSensor entities.Sensor
		entitiesSensor.ID = (*source).ID
		entitiesSensor.CreatedAt = utils.TimeToTime((*source).CreatedAt)
		entitiesSensor.UpdatedAt = utils.TimeToTime((*source).UpdatedAt)
		entitiesSensor.Status = mapper.MapSensorStatus((*source).Status)
		entitiesSensor.Latitude = (*source).Latitude
		entitiesSensor.Longitude = (*source).Longitude
		entitiesSensor.Provider = utils.StringPtrToString((*source).Provider)
		mapStringUnknown, err := utils.MapAdditionalInfo((*source).AdditionalInformations)
		if err != nil {
			return nil, err
		}
		entitiesSensor.AdditionalInfo = mapStringUnknown
		pEntitiesSensor = &entitiesSensor
	}
	return pEntitiesSensor, nil
}
func (c *InternalSensorRepoMapperImpl) FromSqlList(source []*sqlc.Sensor) ([]*entities.Sensor, error) {
	var pEntitiesSensorList []*entities.Sensor
	if source != nil {
		pEntitiesSensorList = make([]*entities.Sensor, len(source))
		for i := 0; i < len(source); i++ {
			pEntitiesSensor, err := c.FromSql(source[i])
			if err != nil {
				return nil, err
			}
			pEntitiesSensorList[i] = pEntitiesSensor
		}
	}
	return pEntitiesSensorList, nil
}
func (c *InternalSensorRepoMapperImpl) FromSqlSensorData(source *sqlc.SensorDatum) (*entities.SensorData, error) {
	var pEntitiesSensorData *entities.SensorData
	if source != nil {
		var entitiesSensorData entities.SensorData
		entitiesSensorData.ID = (*source).ID
		entitiesSensorData.SensorID = (*source).SensorID
		entitiesSensorData.CreatedAt = utils.TimeToTime((*source).CreatedAt)
		entitiesSensorData.UpdatedAt = utils.TimeToTime((*source).UpdatedAt)
		pEntitiesMqttPayload, err := mapper.MapSensorData((*source).Data)
		if err != nil {
			return nil, err
		}
		entitiesSensorData.Data = pEntitiesMqttPayload
		pEntitiesSensorData = &entitiesSensorData
	}
	return pEntitiesSensorData, nil
}
func (c *InternalSensorRepoMapperImpl) FromSqlSensorDataList(source []*sqlc.SensorDatum) ([]*entities.SensorData, error) {
	var pEntitiesSensorDataList []*entities.SensorData
	if source != nil {
		pEntitiesSensorDataList = make([]*entities.SensorData, len(source))
		for i := 0; i < len(source); i++ {
			pEntitiesSensorData, err := c.FromSqlSensorData(source[i])
			if err != nil {
				return nil, err
			}
			pEntitiesSensorDataList[i] = pEntitiesSensorData
		}
	}
	return pEntitiesSensorDataList, nil
}
func (c *InternalSensorRepoMapperImpl) entitiesWatermarkToEntitiesWatermark(source entities.Watermark) entities1.Watermark {
	var entitiesWatermark entities1.Watermark
	entitiesWatermark.Resistance = source.Resistance
	entitiesWatermark.Centibar = source.Centibar
	entitiesWatermark.Depth = source.Depth
	return entitiesWatermark
}

type InternalTreeClusterRepoMapperImpl struct{}

func (c *InternalTreeClusterRepoMapperImpl) FromSql(source *sqlc.TreeCluster) (*entities.TreeCluster, error) {
	var pEntitiesTreeCluster *entities.TreeCluster
	if source != nil {
		var entitiesTreeCluster entities.TreeCluster
		entitiesTreeCluster.ID = (*source).ID
		entitiesTreeCluster.CreatedAt = utils.TimeToTime((*source).CreatedAt)
		entitiesTreeCluster.UpdatedAt = utils.TimeToTime((*source).UpdatedAt)
		entitiesTreeCluster.WateringStatus = mapper.MapWateringStatus((*source).WateringStatus)
		entitiesTreeCluster.LastWatered = c.pTimeTimeToPTimeTime((*source).LastWatered)
		entitiesTreeCluster.MoistureLevel = (*source).MoistureLevel
		entitiesTreeCluster.Address = (*source).Address
		entitiesTreeCluster.Description = (*source).Description
		entitiesTreeCluster.Archived = (*source).Archived
		if (*source).Latitude != nil {
			xfloat64 := *(*source).Latitude
			entitiesTreeCluster.Latitude = &xfloat64
		}
		if (*source).Longitude != nil {
			xfloat642 := *(*source).Longitude
			entitiesTreeCluster.Longitude = &xfloat642
		}
		entitiesTreeCluster.SoilCondition = mapper.MapSoilCondition((*source).SoilCondition)
		entitiesTreeCluster.Name = (*source).Name
		entitiesTreeCluster.Provider = utils.StringPtrToString((*source).Provider)
		mapStringUnknown, err := utils.MapAdditionalInfo((*source).AdditionalInformations)
		if err != nil {
			return nil, err
		}
		entitiesTreeCluster.AdditionalInfo = mapStringUnknown
		pEntitiesTreeCluster = &entitiesTreeCluster
	}
	return pEntitiesTreeCluster, nil
}
func (c *InternalTreeClusterRepoMapperImpl) FromSqlList(source []*sqlc.TreeCluster) ([]*entities.TreeCluster, error) {
	var pEntitiesTreeClusterList []*entities.TreeCluster
	if source != nil {
		pEntitiesTreeClusterList = make([]*entities.TreeCluster, len(source))
		for i := 0; i < len(source); i++ {
			pEntitiesTreeCluster, err := c.FromSql(source[i])
			if err != nil {
				return nil, err
			}
			pEntitiesTreeClusterList[i] = pEntitiesTreeCluster
		}
	}
	return pEntitiesTreeClusterList, nil
}
func (c *InternalTreeClusterRepoMapperImpl) FromSqlRegionListWithCount(source []*sqlc.GetAllTreeClusterRegionsWithWateringPlanCountRow) ([]*entities.RegionEvaluation, error) {
	var pEntitiesRegionEvaluationList []*entities.RegionEvaluation
	if source != nil {
		pEntitiesRegionEvaluationList = make([]*entities.RegionEvaluation, len(source))
		for i := 0; i < len(source); i++ {
			pEntitiesRegionEvaluation, err := c.FromSqlRegionWithCount(source[i])
			if err != nil {
				return nil, err
			}
			pEntitiesRegionEvaluationList[i] = pEntitiesRegionEvaluation
		}
	}
	return pEntitiesRegionEvaluationList, nil
}
func (c *InternalTreeClusterRepoMapperImpl) FromSqlRegionWithCount(source *sqlc.GetAllTreeClusterRegionsWithWateringPlanCountRow) (*entities.RegionEvaluation, error) {
	var pEntitiesRegionEvaluation *entities.RegionEvaluation
	if source != nil {
		var entitiesRegionEvaluation entities.RegionEvaluation
		entitiesRegionEvaluation.Name = (*source).Name
		entitiesRegionEvaluation.WateringPlanCount = (*source).WateringPlanCount
		pEntitiesRegionEvaluation = &entitiesRegionEvaluation
	}
	return pEntitiesRegionEvaluation, nil
}
func (c *InternalTreeClusterRepoMapperImpl) pTimeTimeToPTimeTime(source *time.Time) *time.Time {
	var pTimeTime *time.Time
	if source != nil {
		timeTime := utils.TimeToTime((*source))
		pTimeTime = &timeTime
	}
	return pTimeTime
}

type InternalTreeRepoMapperImpl struct{}

func (c *InternalTreeRepoMapperImpl) FromSql(source *sqlc.Tree) (*entities.Tree, error) {
	var pEntitiesTree *entities.Tree
	if source != nil {
		var entitiesTree entities.Tree
		entitiesTree.ID = (*source).ID
		entitiesTree.CreatedAt = utils.TimeToTime((*source).CreatedAt)
		entitiesTree.UpdatedAt = utils.TimeToTime((*source).UpdatedAt)
		entitiesTree.PlantingYear = (*source).PlantingYear
		entitiesTree.Species = (*source).Species
		entitiesTree.Number = (*source).Number
		entitiesTree.Latitude = (*source).Latitude
		entitiesTree.Longitude = (*source).Longitude
		entitiesTree.WateringStatus = mapper.MapWateringStatus((*source).WateringStatus)
		entitiesTree.Description = utils.StringPtrToString((*source).Description)
		entitiesTree.LastWatered = c.pTimeTimeToPTimeTime2((*source).LastWatered)
		entitiesTree.Provider = utils.StringPtrToString((*source).Provider)
		mapStringUnknown, err := utils.MapAdditionalInfo((*source).AdditionalInformations)
		if err != nil {
			return nil, err
		}
		entitiesTree.AdditionalInfo = mapStringUnknown
		pEntitiesTree = &entitiesTree
	}
	return pEntitiesTree, nil
}
func (c *InternalTreeRepoMapperImpl) FromSqlList(source []*sqlc.Tree) ([]*entities.Tree, error) {
	var pEntitiesTreeList []*entities.Tree
	if source != nil {
		pEntitiesTreeList = make([]*entities.Tree, len(source))
		for i := 0; i < len(source); i++ {
			pEntitiesTree, err := c.FromSql(source[i])
			if err != nil {
				return nil, err
			}
			pEntitiesTreeList[i] = pEntitiesTree
		}
	}
	return pEntitiesTreeList, nil
}
func (c *InternalTreeRepoMapperImpl) pTimeTimeToPTimeTime2(source *time.Time) *time.Time {
	var pTimeTime *time.Time
	if source != nil {
		timeTime := utils.TimeToTime((*source))
		pTimeTime = &timeTime
	}
	return pTimeTime
}

type InternalVehicleRepoMapperImpl struct{}

func (c *InternalVehicleRepoMapperImpl) FromSql(source *sqlc.Vehicle) (*entities.Vehicle, error) {
	var pEntitiesVehicle *entities.Vehicle
	if source != nil {
		var entitiesVehicle entities.Vehicle
		entitiesVehicle.ID = (*source).ID
		entitiesVehicle.CreatedAt = utils.TimeToTime((*source).CreatedAt)
		entitiesVehicle.UpdatedAt = utils.TimeToTime((*source).UpdatedAt)
		entitiesVehicle.ArchivedAt = utils.TimePtrToTime((*source).ArchivedAt)
		entitiesVehicle.NumberPlate = (*source).NumberPlate
		entitiesVehicle.Description = (*source).Description
		entitiesVehicle.WaterCapacity = (*source).WaterCapacity
		entitiesVehicle.Status = mapper.MapVehicleStatus((*source).Status)
		entitiesVehicle.Type = mapper.MapVehicleType((*source).Type)
		entitiesVehicle.Model = (*source).Model
		entitiesVehicle.DrivingLicense = mapper.MapDrivingLicense((*source).DrivingLicense)
		entitiesVehicle.Height = (*source).Height
		entitiesVehicle.Width = (*source).Width
		entitiesVehicle.Length = (*source).Length
		entitiesVehicle.Weight = (*source).Weight
		entitiesVehicle.Provider = utils.StringPtrToString((*source).Provider)
		mapStringUnknown, err := utils.MapAdditionalInfo((*source).AdditionalInformations)
		if err != nil {
			return nil, err
		}
		entitiesVehicle.AdditionalInfo = mapStringUnknown
		pEntitiesVehicle = &entitiesVehicle
	}
	return pEntitiesVehicle, nil
}
func (c *InternalVehicleRepoMapperImpl) FromSqlList(source []*sqlc.Vehicle) ([]*entities.Vehicle, error) {
	var pEntitiesVehicleList []*entities.Vehicle
	if source != nil {
		pEntitiesVehicleList = make([]*entities.Vehicle, len(source))
		for i := 0; i < len(source); i++ {
			pEntitiesVehicle, err := c.FromSql(source[i])
			if err != nil {
				return nil, err
			}
			pEntitiesVehicleList[i] = pEntitiesVehicle
		}
	}
	return pEntitiesVehicleList, nil
}
func (c *InternalVehicleRepoMapperImpl) FromSqlListVehicleWithCount(source []*sqlc.GetAllVehiclesWithWateringPlanCountRow) ([]*entities.VehicleEvaluation, error) {
	var pEntitiesVehicleEvaluationList []*entities.VehicleEvaluation
	if source != nil {
		pEntitiesVehicleEvaluationList = make([]*entities.VehicleEvaluation, len(source))
		for i := 0; i < len(source); i++ {
			pEntitiesVehicleEvaluation, err := c.FromSqlVehicleWithCount(source[i])
			if err != nil {
				return nil, err
			}
			pEntitiesVehicleEvaluationList[i] = pEntitiesVehicleEvaluation
		}
	}
	return pEntitiesVehicleEvaluationList, nil
}
func (c *InternalVehicleRepoMapperImpl) FromSqlVehicleWithCount(source *sqlc.GetAllVehiclesWithWateringPlanCountRow) (*entities.VehicleEvaluation, error) {
	var pEntitiesVehicleEvaluation *entities.VehicleEvaluation
	if source != nil {
		var entitiesVehicleEvaluation entities.VehicleEvaluation
		entitiesVehicleEvaluation.NumberPlate = (*source).NumberPlate
		entitiesVehicleEvaluation.WateringPlanCount = (*source).WateringPlanCount
		pEntitiesVehicleEvaluation = &entitiesVehicleEvaluation
	}
	return pEntitiesVehicleEvaluation, nil
}

type InternalWateringPlanRepoMapperImpl struct{}

func (c *InternalWateringPlanRepoMapperImpl) EvaluationFromSqlList(source []*sqlc.TreeClusterWateringPlan) []*entities.EvaluationValue {
	var pEntitiesEvaluationValueList []*entities.EvaluationValue
	if source != nil {
		pEntitiesEvaluationValueList = make([]*entities.EvaluationValue, len(source))
		for i := 0; i < len(source); i++ {
			pEntitiesEvaluationValueList[i] = c.pSqlcTreeClusterWateringPlanToPEntitiesEvaluationValue(source[i])
		}
	}
	return pEntitiesEvaluationValueList
}
func (c *InternalWateringPlanRepoMapperImpl) FromSql(source *sqlc.WateringPlan) (*entities.WateringPlan, error) {
	var pEntitiesWateringPlan *entities.WateringPlan
	if source != nil {
		var entitiesWateringPlan entities.WateringPlan
		entitiesWateringPlan.ID = (*source).ID
		entitiesWateringPlan.CreatedAt = utils.TimeToTime((*source).CreatedAt)
		entitiesWateringPlan.UpdatedAt = utils.TimeToTime((*source).UpdatedAt)
		entitiesWateringPlan.Date = utils.TimeToTime((*source).Date)
		entitiesWateringPlan.Description = (*source).Description
		entitiesWateringPlan.Status = mapper.MapWateringPlanStatus((*source).Status)
		if (*source).Distance != nil {
			xfloat64 := *(*source).Distance
			entitiesWateringPlan.Distance = &xfloat64
		}
		if (*source).TotalWaterRequired != nil {
			xfloat642 := *(*source).TotalWaterRequired
			entitiesWateringPlan.TotalWaterRequired = &xfloat642
		}
		entitiesWateringPlan.CancellationNote = (*source).CancellationNote
		entitiesWateringPlan.GpxURL = utils.StringPtrToString((*source).GpxUrl)
		entitiesWateringPlan.RefillCount = (*source).RefillCount
		entitiesWateringPlan.Duration = utils.Float64ToDuration((*source).Duration)
		entitiesWateringPlan.Provider = utils.StringPtrToString((*source).Provider)
		mapStringUnknown, err := utils.MapAdditionalInfo((*source).AdditionalInformations)
		if err != nil {
			return nil, err
		}
		entitiesWateringPlan.AdditionalInfo = mapStringUnknown
		pEntitiesWateringPlan = &entitiesWateringPlan
	}
	return pEntitiesWateringPlan, nil
}
func (c *InternalWateringPlanRepoMapperImpl) FromSqlList(source []*sqlc.WateringPlan) ([]*entities.WateringPlan, error) {
	var pEntitiesWateringPlanList []*entities.WateringPlan
	if source != nil {
		pEntitiesWateringPlanList = make([]*entities.WateringPlan, len(source))
		for i := 0; i < len(source); i++ {
			pEntitiesWateringPlan, err := c.FromSql(source[i])
			if err != nil {
				return nil, err
			}
			pEntitiesWateringPlanList[i] = pEntitiesWateringPlan
		}
	}
	return pEntitiesWateringPlanList, nil
}
func (c *InternalWateringPlanRepoMapperImpl) pSqlcTreeClusterWateringPlanToPEntitiesEvaluationValue(source *sqlc.TreeClusterWateringPlan) *entities.EvaluationValue {
	var pEntitiesEvaluationValue *entities.EvaluationValue
	if source != nil {
		var entitiesEvaluationValue entities.EvaluationValue
		entitiesEvaluationValue.WateringPlanID = (*source).WateringPlanID
		entitiesEvaluationValue.TreeClusterID = (*source).TreeClusterID
		pFloat64 := (*source).ConsumedWater
		entitiesEvaluationValue.ConsumedWater = &pFloat64
		pEntitiesEvaluationValue = &entitiesEvaluationValue
	}
	return pEntitiesEvaluationValue
}
