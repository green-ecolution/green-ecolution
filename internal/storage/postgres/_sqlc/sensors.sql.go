// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: sensors.sql

package sqlc

import (
	"context"
)

const createSensor = `-- name: CreateSensor :one
INSERT INTO sensors (
    id, status, latitude, longitude, provider, additional_informations
) VALUES (
  $1, $2, $3, $4, $5, $6
) RETURNING id
`

type CreateSensorParams struct {
	ID                     string
	Status                 SensorStatus
	Latitude               float64
	Longitude              float64
	Provider               *string
	AdditionalInformations []byte
}

func (q *Queries) CreateSensor(ctx context.Context, arg *CreateSensorParams) (string, error) {
	row := q.db.QueryRow(ctx, createSensor,
		arg.ID,
		arg.Status,
		arg.Latitude,
		arg.Longitude,
		arg.Provider,
		arg.AdditionalInformations,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteSensor = `-- name: DeleteSensor :exec
DELETE FROM sensors WHERE id = $1
`

func (q *Queries) DeleteSensor(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteSensor, id)
	return err
}

const getAllSensorDataByID = `-- name: GetAllSensorDataByID :many
SELECT id, created_at, updated_at, data, sensor_id
FROM sensor_data
WHERE sensor_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetAllSensorDataByID(ctx context.Context, sensorID string) ([]*SensorDatum, error) {
	rows, err := q.db.Query(ctx, getAllSensorDataByID, sensorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SensorDatum{}
	for rows.Next() {
		var i SensorDatum
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Data,
			&i.SensorID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSensors = `-- name: GetAllSensors :many
SELECT id, created_at, updated_at, status, latitude, longitude, geometry, provider, additional_informations FROM sensors 
WHERE (COALESCE($3, '') = '' OR provider = $3)
ORDER BY id 
LIMIT $1 OFFSET $2
`

type GetAllSensorsParams struct {
	Limit    int32
	Offset   int32
	Provider interface{}
}

func (q *Queries) GetAllSensors(ctx context.Context, arg *GetAllSensorsParams) ([]*Sensor, error) {
	rows, err := q.db.Query(ctx, getAllSensors, arg.Limit, arg.Offset, arg.Provider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Sensor{}
	for rows.Next() {
		var i Sensor
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.Latitude,
			&i.Longitude,
			&i.Geometry,
			&i.Provider,
			&i.AdditionalInformations,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSensorsCount = `-- name: GetAllSensorsCount :one
SELECT COUNT(*) FROM sensors
WHERE (COALESCE($1, '') = '' OR provider = $1)
`

func (q *Queries) GetAllSensorsCount(ctx context.Context, provider interface{}) (int64, error) {
	row := q.db.QueryRow(ctx, getAllSensorsCount, provider)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLatestSensorDataByID = `-- name: GetLatestSensorDataByID :one
SELECT id, created_at, updated_at, data, sensor_id
FROM sensor_data
WHERE sensor_id = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestSensorDataByID(ctx context.Context, sensorID string) (*SensorDatum, error) {
	row := q.db.QueryRow(ctx, getLatestSensorDataByID, sensorID)
	var i SensorDatum
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Data,
		&i.SensorID,
	)
	return &i, err
}

const getSensorByID = `-- name: GetSensorByID :one
SELECT id, created_at, updated_at, status, latitude, longitude, geometry, provider, additional_informations FROM sensors WHERE id = $1
`

func (q *Queries) GetSensorByID(ctx context.Context, id string) (*Sensor, error) {
	row := q.db.QueryRow(ctx, getSensorByID, id)
	var i Sensor
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.Latitude,
		&i.Longitude,
		&i.Geometry,
		&i.Provider,
		&i.AdditionalInformations,
	)
	return &i, err
}

const getSensorByStatus = `-- name: GetSensorByStatus :many
SELECT id, created_at, updated_at, status, latitude, longitude, geometry, provider, additional_informations FROM sensors WHERE status = $1
`

func (q *Queries) GetSensorByStatus(ctx context.Context, status SensorStatus) ([]*Sensor, error) {
	rows, err := q.db.Query(ctx, getSensorByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Sensor{}
	for rows.Next() {
		var i Sensor
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.Latitude,
			&i.Longitude,
			&i.Geometry,
			&i.Provider,
			&i.AdditionalInformations,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertSensorData = `-- name: InsertSensorData :exec
INSERT INTO sensor_data (
  sensor_id, data
) VALUES (
  $1, $2
) RETURNING id
`

type InsertSensorDataParams struct {
	SensorID string
	Data     []byte
}

func (q *Queries) InsertSensorData(ctx context.Context, arg *InsertSensorDataParams) error {
	_, err := q.db.Exec(ctx, insertSensorData, arg.SensorID, arg.Data)
	return err
}

const setSensorLocation = `-- name: SetSensorLocation :exec
UPDATE sensors SET
    latitude = $2,
    longitude = $3,
    geometry = ST_SetSRID(ST_MakePoint($2, $3), 4326)
WHERE id = $1
`

type SetSensorLocationParams struct {
	ID        string
	Latitude  float64
	Longitude float64
}

func (q *Queries) SetSensorLocation(ctx context.Context, arg *SetSensorLocationParams) error {
	_, err := q.db.Exec(ctx, setSensorLocation, arg.ID, arg.Latitude, arg.Longitude)
	return err
}

const updateSensor = `-- name: UpdateSensor :exec
UPDATE sensors SET
  status = $2,
  provider = $3,
  additional_informations = $4
WHERE id = $1
`

type UpdateSensorParams struct {
	ID                     string
	Status                 SensorStatus
	Provider               *string
	AdditionalInformations []byte
}

func (q *Queries) UpdateSensor(ctx context.Context, arg *UpdateSensorParams) error {
	_, err := q.db.Exec(ctx, updateSensor,
		arg.ID,
		arg.Status,
		arg.Provider,
		arg.AdditionalInformations,
	)
	return err
}
