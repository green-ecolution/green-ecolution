// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: vehicles.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const archiveVehicle = `-- name: ArchiveVehicle :one
UPDATE vehicles SET archived_at = $2 WHERE id = $1 RETURNING id
`

type ArchiveVehicleParams struct {
	ID         int32
	ArchivedAt pgtype.Timestamp
}

func (q *Queries) ArchiveVehicle(ctx context.Context, arg *ArchiveVehicleParams) (int32, error) {
	row := q.db.QueryRow(ctx, archiveVehicle, arg.ID, arg.ArchivedAt)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createVehicle = `-- name: CreateVehicle :one
INSERT INTO vehicles (
  number_plate, 
  description, 
  water_capacity, 
  type, 
  status, 
  model, 
  driving_license, 
  height, 
  length, 
  width,
  weight,
  provider,
  additional_informations
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING id
`

type CreateVehicleParams struct {
	NumberPlate            string
	Description            string
	WaterCapacity          float64
	Type                   VehicleType
	Status                 VehicleStatus
	Model                  string
	DrivingLicense         DrivingLicense
	Height                 float64
	Length                 float64
	Width                  float64
	Weight                 float64
	Provider               *string
	AdditionalInformations []byte
}

func (q *Queries) CreateVehicle(ctx context.Context, arg *CreateVehicleParams) (int32, error) {
	row := q.db.QueryRow(ctx, createVehicle,
		arg.NumberPlate,
		arg.Description,
		arg.WaterCapacity,
		arg.Type,
		arg.Status,
		arg.Model,
		arg.DrivingLicense,
		arg.Height,
		arg.Length,
		arg.Width,
		arg.Weight,
		arg.Provider,
		arg.AdditionalInformations,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteVehicle = `-- name: DeleteVehicle :one
DELETE FROM vehicles WHERE id = $1 RETURNING id
`

func (q *Queries) DeleteVehicle(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, deleteVehicle, id)
	err := row.Scan(&id)
	return id, err
}

const getAllArchivedVehicles = `-- name: GetAllArchivedVehicles :many
SELECT id, created_at, updated_at, number_plate, description, water_capacity, type, status, model, driving_license, height, length, width, weight, provider, additional_informations, archived_at
FROM vehicles
WHERE
  archived_at IS NOT NULL
ORDER BY water_capacity DESC
`

func (q *Queries) GetAllArchivedVehicles(ctx context.Context) ([]*Vehicle, error) {
	rows, err := q.db.Query(ctx, getAllArchivedVehicles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Vehicle{}
	for rows.Next() {
		var i Vehicle
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NumberPlate,
			&i.Description,
			&i.WaterCapacity,
			&i.Type,
			&i.Status,
			&i.Model,
			&i.DrivingLicense,
			&i.Height,
			&i.Length,
			&i.Width,
			&i.Weight,
			&i.Provider,
			&i.AdditionalInformations,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllVehicles = `-- name: GetAllVehicles :many
SELECT id, created_at, updated_at, number_plate, description, water_capacity, type, status, model, driving_license, height, length, width, weight, provider, additional_informations, archived_at 
FROM vehicles 
WHERE
    (COALESCE($3, '') = '' OR provider = $3)
    AND archived_at IS NULL
ORDER BY water_capacity DESC
LIMIT $1 OFFSET $2
`

type GetAllVehiclesParams struct {
	Limit    int32
	Offset   int32
	Provider interface{}
}

func (q *Queries) GetAllVehicles(ctx context.Context, arg *GetAllVehiclesParams) ([]*Vehicle, error) {
	rows, err := q.db.Query(ctx, getAllVehicles, arg.Limit, arg.Offset, arg.Provider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Vehicle{}
	for rows.Next() {
		var i Vehicle
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NumberPlate,
			&i.Description,
			&i.WaterCapacity,
			&i.Type,
			&i.Status,
			&i.Model,
			&i.DrivingLicense,
			&i.Height,
			&i.Length,
			&i.Width,
			&i.Weight,
			&i.Provider,
			&i.AdditionalInformations,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllVehiclesByType = `-- name: GetAllVehiclesByType :many
SELECT id, created_at, updated_at, number_plate, description, water_capacity, type, status, model, driving_license, height, length, width, weight, provider, additional_informations, archived_at 
FROM vehicles 
WHERE
    (COALESCE($4, '') = '' OR provider = $4)
  AND archived_at IS NULL
  AND type = $1
ORDER BY water_capacity DESC
LIMIT $2 OFFSET $3
`

type GetAllVehiclesByTypeParams struct {
	Type     VehicleType
	Limit    int32
	Offset   int32
	Provider interface{}
}

func (q *Queries) GetAllVehiclesByType(ctx context.Context, arg *GetAllVehiclesByTypeParams) ([]*Vehicle, error) {
	rows, err := q.db.Query(ctx, getAllVehiclesByType,
		arg.Type,
		arg.Limit,
		arg.Offset,
		arg.Provider,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Vehicle{}
	for rows.Next() {
		var i Vehicle
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NumberPlate,
			&i.Description,
			&i.WaterCapacity,
			&i.Type,
			&i.Status,
			&i.Model,
			&i.DrivingLicense,
			&i.Height,
			&i.Length,
			&i.Width,
			&i.Weight,
			&i.Provider,
			&i.AdditionalInformations,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllVehiclesByTypeCount = `-- name: GetAllVehiclesByTypeCount :one
SELECT COUNT(*) 
  FROM vehicles 
  WHERE
    (COALESCE($2, '') = '' OR provider = $2)
    AND archived_at IS NULL
    AND type = $1
`

type GetAllVehiclesByTypeCountParams struct {
	Type     VehicleType
	Provider interface{}
}

func (q *Queries) GetAllVehiclesByTypeCount(ctx context.Context, arg *GetAllVehiclesByTypeCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getAllVehiclesByTypeCount, arg.Type, arg.Provider)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllVehiclesByTypeWithArchived = `-- name: GetAllVehiclesByTypeWithArchived :many
SELECT id, created_at, updated_at, number_plate, description, water_capacity, type, status, model, driving_license, height, length, width, weight, provider, additional_informations, archived_at
FROM vehicles
WHERE
    (COALESCE($4, '') = '' OR provider = $4)
    AND
    type = $1
ORDER BY water_capacity DESC
LIMIT $2 OFFSET $3
`

type GetAllVehiclesByTypeWithArchivedParams struct {
	Type     VehicleType
	Limit    int32
	Offset   int32
	Provider interface{}
}

func (q *Queries) GetAllVehiclesByTypeWithArchived(ctx context.Context, arg *GetAllVehiclesByTypeWithArchivedParams) ([]*Vehicle, error) {
	rows, err := q.db.Query(ctx, getAllVehiclesByTypeWithArchived,
		arg.Type,
		arg.Limit,
		arg.Offset,
		arg.Provider,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Vehicle{}
	for rows.Next() {
		var i Vehicle
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NumberPlate,
			&i.Description,
			&i.WaterCapacity,
			&i.Type,
			&i.Status,
			&i.Model,
			&i.DrivingLicense,
			&i.Height,
			&i.Length,
			&i.Width,
			&i.Weight,
			&i.Provider,
			&i.AdditionalInformations,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllVehiclesByTypeWithArchivedCount = `-- name: GetAllVehiclesByTypeWithArchivedCount :one
SELECT COUNT(*)
  FROM vehicles
  WHERE
    (COALESCE($2, '') = '' OR provider = $2)
    AND
    type = $1
`

type GetAllVehiclesByTypeWithArchivedCountParams struct {
	Type     VehicleType
	Provider interface{}
}

func (q *Queries) GetAllVehiclesByTypeWithArchivedCount(ctx context.Context, arg *GetAllVehiclesByTypeWithArchivedCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getAllVehiclesByTypeWithArchivedCount, arg.Type, arg.Provider)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllVehiclesCount = `-- name: GetAllVehiclesCount :one
SELECT COUNT(*)
  FROM vehicles
  WHERE
    (COALESCE($1, '') = '' OR provider = $1)
    AND archived_at IS NULL
`

func (q *Queries) GetAllVehiclesCount(ctx context.Context, provider interface{}) (int64, error) {
	row := q.db.QueryRow(ctx, getAllVehiclesCount, provider)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllVehiclesWithArchived = `-- name: GetAllVehiclesWithArchived :many
SELECT id, created_at, updated_at, number_plate, description, water_capacity, type, status, model, driving_license, height, length, width, weight, provider, additional_informations, archived_at FROM vehicles
WHERE
    (COALESCE($3, '') = '' OR provider = $3)
ORDER BY water_capacity DESC
LIMIT $1 OFFSET $2
`

type GetAllVehiclesWithArchivedParams struct {
	Limit    int32
	Offset   int32
	Provider interface{}
}

func (q *Queries) GetAllVehiclesWithArchived(ctx context.Context, arg *GetAllVehiclesWithArchivedParams) ([]*Vehicle, error) {
	rows, err := q.db.Query(ctx, getAllVehiclesWithArchived, arg.Limit, arg.Offset, arg.Provider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Vehicle{}
	for rows.Next() {
		var i Vehicle
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NumberPlate,
			&i.Description,
			&i.WaterCapacity,
			&i.Type,
			&i.Status,
			&i.Model,
			&i.DrivingLicense,
			&i.Height,
			&i.Length,
			&i.Width,
			&i.Weight,
			&i.Provider,
			&i.AdditionalInformations,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllVehiclesWithArchivedCount = `-- name: GetAllVehiclesWithArchivedCount :one
SELECT COUNT(*)
  FROM vehicles 
  WHERE
    (COALESCE($1, '') = '' OR provider = $1)
`

func (q *Queries) GetAllVehiclesWithArchivedCount(ctx context.Context, provider interface{}) (int64, error) {
	row := q.db.QueryRow(ctx, getAllVehiclesWithArchivedCount, provider)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllVehiclesWithWateringPlanCount = `-- name: GetAllVehiclesWithWateringPlanCount :many
SELECT 
    v.number_plate,
    COUNT(vwp.watering_plan_id) AS watering_plan_count
FROM vehicles v
INNER JOIN vehicle_watering_plans vwp ON v.id = vwp.vehicle_id
GROUP BY v.number_plate
ORDER BY watering_plan_count DESC
`

type GetAllVehiclesWithWateringPlanCountRow struct {
	NumberPlate       string
	WateringPlanCount int64
}

func (q *Queries) GetAllVehiclesWithWateringPlanCount(ctx context.Context) ([]*GetAllVehiclesWithWateringPlanCountRow, error) {
	rows, err := q.db.Query(ctx, getAllVehiclesWithWateringPlanCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAllVehiclesWithWateringPlanCountRow{}
	for rows.Next() {
		var i GetAllVehiclesWithWateringPlanCountRow
		if err := rows.Scan(&i.NumberPlate, &i.WateringPlanCount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVehicleByID = `-- name: GetVehicleByID :one
SELECT id, created_at, updated_at, number_plate, description, water_capacity, type, status, model, driving_license, height, length, width, weight, provider, additional_informations, archived_at FROM vehicles WHERE id = $1
`

func (q *Queries) GetVehicleByID(ctx context.Context, id int32) (*Vehicle, error) {
	row := q.db.QueryRow(ctx, getVehicleByID, id)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NumberPlate,
		&i.Description,
		&i.WaterCapacity,
		&i.Type,
		&i.Status,
		&i.Model,
		&i.DrivingLicense,
		&i.Height,
		&i.Length,
		&i.Width,
		&i.Weight,
		&i.Provider,
		&i.AdditionalInformations,
		&i.ArchivedAt,
	)
	return &i, err
}

const getVehicleByPlate = `-- name: GetVehicleByPlate :one
SELECT id, created_at, updated_at, number_plate, description, water_capacity, type, status, model, driving_license, height, length, width, weight, provider, additional_informations, archived_at FROM vehicles WHERE number_plate = $1
`

func (q *Queries) GetVehicleByPlate(ctx context.Context, numberPlate string) (*Vehicle, error) {
	row := q.db.QueryRow(ctx, getVehicleByPlate, numberPlate)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NumberPlate,
		&i.Description,
		&i.WaterCapacity,
		&i.Type,
		&i.Status,
		&i.Model,
		&i.DrivingLicense,
		&i.Height,
		&i.Length,
		&i.Width,
		&i.Weight,
		&i.Provider,
		&i.AdditionalInformations,
		&i.ArchivedAt,
	)
	return &i, err
}

const updateVehicle = `-- name: UpdateVehicle :exec
UPDATE vehicles SET
  number_plate = $2,
  description = $3,
  water_capacity = $4,
  type = $5,
  status = $6,
  model = $7,
  driving_license = $8,
  height = $9,
  length = $10,
  width = $11,
  weight = $12,
  provider = $13,
  additional_informations = $14
WHERE id = $1
`

type UpdateVehicleParams struct {
	ID                     int32
	NumberPlate            string
	Description            string
	WaterCapacity          float64
	Type                   VehicleType
	Status                 VehicleStatus
	Model                  string
	DrivingLicense         DrivingLicense
	Height                 float64
	Length                 float64
	Width                  float64
	Weight                 float64
	Provider               *string
	AdditionalInformations []byte
}

func (q *Queries) UpdateVehicle(ctx context.Context, arg *UpdateVehicleParams) error {
	_, err := q.db.Exec(ctx, updateVehicle,
		arg.ID,
		arg.NumberPlate,
		arg.Description,
		arg.WaterCapacity,
		arg.Type,
		arg.Status,
		arg.Model,
		arg.DrivingLicense,
		arg.Height,
		arg.Length,
		arg.Width,
		arg.Weight,
		arg.Provider,
		arg.AdditionalInformations,
	)
	return err
}
