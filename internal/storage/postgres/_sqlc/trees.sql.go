// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: trees.sql

package sqlc

import (
	"context"
	"time"
)

const calculateGroupedCentroids = `-- name: CalculateGroupedCentroids :one
SELECT ST_AsText(ST_Centroid(ST_Collect(geometry)))::text AS centroid FROM trees WHERE id = ANY($1::int[])
`

func (q *Queries) CalculateGroupedCentroids(ctx context.Context, dollar_1 []int32) (string, error) {
	row := q.db.QueryRow(ctx, calculateGroupedCentroids, dollar_1)
	var centroid string
	err := row.Scan(&centroid)
	return centroid, err
}

const createTree = `-- name: CreateTree :one
INSERT INTO trees (
  tree_cluster_id, sensor_id, planting_year, species, number, description, watering_status, latitude, longitude, provider, additional_informations
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id
`

type CreateTreeParams struct {
	TreeClusterID          *int32
	SensorID               *string
	PlantingYear           int32
	Species                string
	Number                 string
	Description            *string
	WateringStatus         WateringStatus
	Latitude               float64
	Longitude              float64
	Provider               *string
	AdditionalInformations []byte
}

func (q *Queries) CreateTree(ctx context.Context, arg *CreateTreeParams) (int32, error) {
	row := q.db.QueryRow(ctx, createTree,
		arg.TreeClusterID,
		arg.SensorID,
		arg.PlantingYear,
		arg.Species,
		arg.Number,
		arg.Description,
		arg.WateringStatus,
		arg.Latitude,
		arg.Longitude,
		arg.Provider,
		arg.AdditionalInformations,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteTree = `-- name: DeleteTree :one
DELETE FROM trees WHERE id = $1 RETURNING id
`

func (q *Queries) DeleteTree(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, deleteTree, id)
	err := row.Scan(&id)
	return id, err
}

const findNearestTree = `-- name: FindNearestTree :one
SELECT id, created_at, updated_at, tree_cluster_id, sensor_id, planting_year, species, number, latitude, longitude, watering_status, geometry, description, provider, additional_informations, last_watered FROM trees
WHERE ST_Distance(geometry::geography, ST_SetSRID(ST_MakePoint($1, $2), 4326)::geography) <= 3
ORDER BY ST_Distance(geometry::geography, ST_SetSRID(ST_MakePoint($1, $2), 4326)::geography) ASC
    LIMIT 1
`

type FindNearestTreeParams struct {
	StMakepoint   interface{}
	StMakepoint_2 interface{}
}

func (q *Queries) FindNearestTree(ctx context.Context, arg *FindNearestTreeParams) (*Tree, error) {
	row := q.db.QueryRow(ctx, findNearestTree, arg.StMakepoint, arg.StMakepoint_2)
	var i Tree
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TreeClusterID,
		&i.SensorID,
		&i.PlantingYear,
		&i.Species,
		&i.Number,
		&i.Latitude,
		&i.Longitude,
		&i.WateringStatus,
		&i.Geometry,
		&i.Description,
		&i.Provider,
		&i.AdditionalInformations,
		&i.LastWatered,
	)
	return &i, err
}

const getAllTrees = `-- name: GetAllTrees :many
SELECT t.id, t.created_at, t.updated_at, t.tree_cluster_id, t.sensor_id, t.planting_year, t.species, t.number, t.latitude, t.longitude, t.watering_status, t.geometry, t.description, t.provider, t.additional_informations, t.last_watered
FROM trees t
WHERE
    (COALESCE(array_length($3::TEXT[], 1), 0) = 0
        OR t.watering_status = ANY(($3::TEXT[])::watering_status[]))
  AND (COALESCE($4, '') = '' OR t.provider = $4)
  AND (COALESCE(array_length($5::INTEGER[], 1), 0) = 0 OR t.planting_year = ANY($5::INTEGER[]))
  AND (
    $6::BOOLEAN IS NULL
    OR (t.tree_cluster_id IS NOT NULL) = $6::BOOLEAN
      )
  ORDER BY t.number ASC
    LIMIT $1 OFFSET $2
`

type GetAllTreesParams struct {
	Limit          int32
	Offset         int32
	WateringStatus []string
	Provider       interface{}
	Years          []int32
	HasCluster     *bool
}

func (q *Queries) GetAllTrees(ctx context.Context, arg *GetAllTreesParams) ([]*Tree, error) {
	rows, err := q.db.Query(ctx, getAllTrees,
		arg.Limit,
		arg.Offset,
		arg.WateringStatus,
		arg.Provider,
		arg.Years,
		arg.HasCluster,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Tree{}
	for rows.Next() {
		var i Tree
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TreeClusterID,
			&i.SensorID,
			&i.PlantingYear,
			&i.Species,
			&i.Number,
			&i.Latitude,
			&i.Longitude,
			&i.WateringStatus,
			&i.Geometry,
			&i.Description,
			&i.Provider,
			&i.AdditionalInformations,
			&i.LastWatered,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTreesCount = `-- name: GetAllTreesCount :one
SELECT COUNT(*)
FROM trees t
WHERE
    (COALESCE(array_length($1::TEXT[], 1), 0) = 0
        OR t.watering_status = ANY(($1::TEXT[])::watering_status[]))
  AND (COALESCE($2, '') = '' OR t.provider = $2)
  AND (COALESCE(array_length($3::INTEGER[], 1), 0) = 0 OR t.planting_year = ANY($3::INTEGER[]))
  AND (
    $4::BOOLEAN IS NULL
    OR (t.tree_cluster_id IS NOT NULL) = $4::BOOLEAN
      )
`

type GetAllTreesCountParams struct {
	WateringStatus []string
	Provider       interface{}
	Years          []int32
	HasCluster     *bool
}

func (q *Queries) GetAllTreesCount(ctx context.Context, arg *GetAllTreesCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getAllTreesCount,
		arg.WateringStatus,
		arg.Provider,
		arg.Years,
		arg.HasCluster,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getSensorByTreeID = `-- name: GetSensorByTreeID :one
SELECT sensors.id, sensors.created_at, sensors.updated_at, sensors.status, sensors.latitude, sensors.longitude, sensors.geometry, sensors.provider, sensors.additional_informations FROM sensors JOIN trees ON sensors.id = trees.sensor_id WHERE trees.id = $1
`

func (q *Queries) GetSensorByTreeID(ctx context.Context, id int32) (*Sensor, error) {
	row := q.db.QueryRow(ctx, getSensorByTreeID, id)
	var i Sensor
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.Latitude,
		&i.Longitude,
		&i.Geometry,
		&i.Provider,
		&i.AdditionalInformations,
	)
	return &i, err
}

const getTreeByCoordinates = `-- name: GetTreeByCoordinates :one
SELECT id, created_at, updated_at, tree_cluster_id, sensor_id, planting_year, species, number, latitude, longitude, watering_status, geometry, description, provider, additional_informations, last_watered FROM trees WHERE latitude = $1 AND longitude = $2 LIMIT 1
`

type GetTreeByCoordinatesParams struct {
	Latitude  float64
	Longitude float64
}

func (q *Queries) GetTreeByCoordinates(ctx context.Context, arg *GetTreeByCoordinatesParams) (*Tree, error) {
	row := q.db.QueryRow(ctx, getTreeByCoordinates, arg.Latitude, arg.Longitude)
	var i Tree
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TreeClusterID,
		&i.SensorID,
		&i.PlantingYear,
		&i.Species,
		&i.Number,
		&i.Latitude,
		&i.Longitude,
		&i.WateringStatus,
		&i.Geometry,
		&i.Description,
		&i.Provider,
		&i.AdditionalInformations,
		&i.LastWatered,
	)
	return &i, err
}

const getTreeByID = `-- name: GetTreeByID :one
SELECT id, created_at, updated_at, tree_cluster_id, sensor_id, planting_year, species, number, latitude, longitude, watering_status, geometry, description, provider, additional_informations, last_watered FROM trees WHERE id = $1
`

func (q *Queries) GetTreeByID(ctx context.Context, id int32) (*Tree, error) {
	row := q.db.QueryRow(ctx, getTreeByID, id)
	var i Tree
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TreeClusterID,
		&i.SensorID,
		&i.PlantingYear,
		&i.Species,
		&i.Number,
		&i.Latitude,
		&i.Longitude,
		&i.WateringStatus,
		&i.Geometry,
		&i.Description,
		&i.Provider,
		&i.AdditionalInformations,
		&i.LastWatered,
	)
	return &i, err
}

const getTreeBySensorID = `-- name: GetTreeBySensorID :one
SELECT id, created_at, updated_at, tree_cluster_id, sensor_id, planting_year, species, number, latitude, longitude, watering_status, geometry, description, provider, additional_informations, last_watered FROM trees WHERE sensor_id = $1
`

func (q *Queries) GetTreeBySensorID(ctx context.Context, sensorID *string) (*Tree, error) {
	row := q.db.QueryRow(ctx, getTreeBySensorID, sensorID)
	var i Tree
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TreeClusterID,
		&i.SensorID,
		&i.PlantingYear,
		&i.Species,
		&i.Number,
		&i.Latitude,
		&i.Longitude,
		&i.WateringStatus,
		&i.Geometry,
		&i.Description,
		&i.Provider,
		&i.AdditionalInformations,
		&i.LastWatered,
	)
	return &i, err
}

const getTreeClusterByTreeID = `-- name: GetTreeClusterByTreeID :one
SELECT tree_clusters.id, tree_clusters.created_at, tree_clusters.updated_at, tree_clusters.watering_status, tree_clusters.last_watered, tree_clusters.moisture_level, tree_clusters.address, tree_clusters.description, tree_clusters.archived, tree_clusters.soil_condition, tree_clusters.latitude, tree_clusters.longitude, tree_clusters.geometry, tree_clusters.region_id, tree_clusters.name, tree_clusters.provider, tree_clusters.additional_informations FROM tree_clusters JOIN trees ON tree_clusters.id = trees.tree_cluster_id WHERE trees.id = $1
`

func (q *Queries) GetTreeClusterByTreeID(ctx context.Context, id int32) (*TreeCluster, error) {
	row := q.db.QueryRow(ctx, getTreeClusterByTreeID, id)
	var i TreeCluster
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.WateringStatus,
		&i.LastWatered,
		&i.MoistureLevel,
		&i.Address,
		&i.Description,
		&i.Archived,
		&i.SoilCondition,
		&i.Latitude,
		&i.Longitude,
		&i.Geometry,
		&i.RegionID,
		&i.Name,
		&i.Provider,
		&i.AdditionalInformations,
	)
	return &i, err
}

const getTreesByIDs = `-- name: GetTreesByIDs :many
SELECT id, created_at, updated_at, tree_cluster_id, sensor_id, planting_year, species, number, latitude, longitude, watering_status, geometry, description, provider, additional_informations, last_watered FROM trees WHERE id = ANY($1::int[]) ORDER BY number ASC
`

func (q *Queries) GetTreesByIDs(ctx context.Context, dollar_1 []int32) ([]*Tree, error) {
	rows, err := q.db.Query(ctx, getTreesByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Tree{}
	for rows.Next() {
		var i Tree
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TreeClusterID,
			&i.SensorID,
			&i.PlantingYear,
			&i.Species,
			&i.Number,
			&i.Latitude,
			&i.Longitude,
			&i.WateringStatus,
			&i.Geometry,
			&i.Description,
			&i.Provider,
			&i.AdditionalInformations,
			&i.LastWatered,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTreesBySensorIDs = `-- name: GetTreesBySensorIDs :many
SELECT id, created_at, updated_at, tree_cluster_id, sensor_id, planting_year, species, number, latitude, longitude, watering_status, geometry, description, provider, additional_informations, last_watered FROM trees WHERE sensor_id = ANY($1::text[]) ORDER BY number ASC
`

func (q *Queries) GetTreesBySensorIDs(ctx context.Context, dollar_1 []string) ([]*Tree, error) {
	rows, err := q.db.Query(ctx, getTreesBySensorIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Tree{}
	for rows.Next() {
		var i Tree
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TreeClusterID,
			&i.SensorID,
			&i.PlantingYear,
			&i.Species,
			&i.Number,
			&i.Latitude,
			&i.Longitude,
			&i.WateringStatus,
			&i.Geometry,
			&i.Description,
			&i.Provider,
			&i.AdditionalInformations,
			&i.LastWatered,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTreesByTreeClusterID = `-- name: GetTreesByTreeClusterID :many
SELECT id, created_at, updated_at, tree_cluster_id, sensor_id, planting_year, species, number, latitude, longitude, watering_status, geometry, description, provider, additional_informations, last_watered FROM trees WHERE tree_cluster_id = $1 ORDER BY number ASC
`

func (q *Queries) GetTreesByTreeClusterID(ctx context.Context, treeClusterID *int32) ([]*Tree, error) {
	rows, err := q.db.Query(ctx, getTreesByTreeClusterID, treeClusterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Tree{}
	for rows.Next() {
		var i Tree
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TreeClusterID,
			&i.SensorID,
			&i.PlantingYear,
			&i.Species,
			&i.Number,
			&i.Latitude,
			&i.Longitude,
			&i.WateringStatus,
			&i.Geometry,
			&i.Description,
			&i.Provider,
			&i.AdditionalInformations,
			&i.LastWatered,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setTreeLocation = `-- name: SetTreeLocation :exec
UPDATE trees SET
  latitude = $2,
  longitude = $3,
  geometry = ST_SetSRID(ST_MakePoint($2, $3), 4326)
WHERE id = $1
`

type SetTreeLocationParams struct {
	ID        int32
	Latitude  float64
	Longitude float64
}

func (q *Queries) SetTreeLocation(ctx context.Context, arg *SetTreeLocationParams) error {
	_, err := q.db.Exec(ctx, setTreeLocation, arg.ID, arg.Latitude, arg.Longitude)
	return err
}

const unlinkSensorIDFromTrees = `-- name: UnlinkSensorIDFromTrees :exec
UPDATE trees
SET sensor_id = NULL, watering_status = 'unknown'
WHERE sensor_id = $1
`

func (q *Queries) UnlinkSensorIDFromTrees(ctx context.Context, sensorID *string) error {
	_, err := q.db.Exec(ctx, unlinkSensorIDFromTrees, sensorID)
	return err
}

const unlinkTreeClusterID = `-- name: UnlinkTreeClusterID :many
UPDATE trees SET tree_cluster_id = NULL WHERE tree_cluster_id = $1 RETURNING id
`

func (q *Queries) UnlinkTreeClusterID(ctx context.Context, treeClusterID *int32) ([]int32, error) {
	rows, err := q.db.Query(ctx, unlinkTreeClusterID, treeClusterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int32{}
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTree = `-- name: UpdateTree :exec
UPDATE trees SET
  tree_cluster_id = $2,
  sensor_id = $3,
  planting_year = $4,
  species = $5,
  number = $6,
  watering_status = $7,
  description = $8,
  provider = $9,
  additional_informations = $10,
  last_watered = $11
WHERE id = $1
`

type UpdateTreeParams struct {
	ID                     int32
	TreeClusterID          *int32
	SensorID               *string
	PlantingYear           int32
	Species                string
	Number                 string
	WateringStatus         WateringStatus
	Description            *string
	Provider               *string
	AdditionalInformations []byte
	LastWatered            *time.Time
}

func (q *Queries) UpdateTree(ctx context.Context, arg *UpdateTreeParams) error {
	_, err := q.db.Exec(ctx, updateTree,
		arg.ID,
		arg.TreeClusterID,
		arg.SensorID,
		arg.PlantingYear,
		arg.Species,
		arg.Number,
		arg.WateringStatus,
		arg.Description,
		arg.Provider,
		arg.AdditionalInformations,
		arg.LastWatered,
	)
	return err
}

const updateTreeClusterID = `-- name: UpdateTreeClusterID :exec
UPDATE trees SET tree_cluster_id = $2 WHERE id = ANY($1::int[])
`

type UpdateTreeClusterIDParams struct {
	Column1       []int32
	TreeClusterID *int32
}

func (q *Queries) UpdateTreeClusterID(ctx context.Context, arg *UpdateTreeClusterIDParams) error {
	_, err := q.db.Exec(ctx, updateTreeClusterID, arg.Column1, arg.TreeClusterID)
	return err
}

const updateTreeGeometry = `-- name: UpdateTreeGeometry :exec
UPDATE trees SET
  geometry = ST_GeomFromText($2, 4326)
WHERE id = $1
`

type UpdateTreeGeometryParams struct {
	ID             int32
	StGeomfromtext interface{}
}

func (q *Queries) UpdateTreeGeometry(ctx context.Context, arg *UpdateTreeGeometryParams) error {
	_, err := q.db.Exec(ctx, updateTreeGeometry, arg.ID, arg.StGeomfromtext)
	return err
}
