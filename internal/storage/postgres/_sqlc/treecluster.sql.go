// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: treecluster.sql

package sqlc

import (
	"context"
	"time"
)

const archiveTreeCluster = `-- name: ArchiveTreeCluster :one
UPDATE tree_clusters SET
  archived = TRUE
WHERE id = $1 RETURNING id
`

func (q *Queries) ArchiveTreeCluster(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, archiveTreeCluster, id)
	err := row.Scan(&id)
	return id, err
}

const calculateTreesCentroid = `-- name: CalculateTreesCentroid :one
SELECT ST_AsText(ST_Centroid(ST_Collect(geometry)))::text AS centroid FROM trees WHERE trees.tree_cluster_id = $1
`

func (q *Queries) CalculateTreesCentroid(ctx context.Context, treeClusterID *int32) (string, error) {
	row := q.db.QueryRow(ctx, calculateTreesCentroid, treeClusterID)
	var centroid string
	err := row.Scan(&centroid)
	return centroid, err
}

const createTreeCluster = `-- name: CreateTreeCluster :one
INSERT INTO tree_clusters (
  name, region_id, address, description, moisture_level, watering_status, soil_condition, provider, additional_informations
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id
`

type CreateTreeClusterParams struct {
	Name                   string
	RegionID               *int32
	Address                string
	Description            string
	MoistureLevel          float64
	WateringStatus         WateringStatus
	SoilCondition          TreeSoilCondition
	Provider               *string
	AdditionalInformations []byte
}

func (q *Queries) CreateTreeCluster(ctx context.Context, arg *CreateTreeClusterParams) (int32, error) {
	row := q.db.QueryRow(ctx, createTreeCluster,
		arg.Name,
		arg.RegionID,
		arg.Address,
		arg.Description,
		arg.MoistureLevel,
		arg.WateringStatus,
		arg.SoilCondition,
		arg.Provider,
		arg.AdditionalInformations,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteTreeCluster = `-- name: DeleteTreeCluster :one
DELETE FROM tree_clusters WHERE id = $1 RETURNING id
`

func (q *Queries) DeleteTreeCluster(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, deleteTreeCluster, id)
	err := row.Scan(&id)
	return id, err
}

const getAllLatestSensorDataByTreeClusterID = `-- name: GetAllLatestSensorDataByTreeClusterID :many
SELECT sd.id, sd.created_at, sd.updated_at, sd.data, sd.sensor_id
FROM sensor_data sd
JOIN sensors s ON sd.sensor_id = s.id
JOIN trees t ON t.sensor_id = s.id
JOIN tree_clusters tc ON t.tree_cluster_id = tc.id
WHERE tc.id = $1
  AND sd.id = (
    SELECT id
    FROM sensor_data
    WHERE sensor_id = s.id
    ORDER BY created_at DESC
    LIMIT 1
  )
`

func (q *Queries) GetAllLatestSensorDataByTreeClusterID(ctx context.Context, id int32) ([]*SensorDatum, error) {
	rows, err := q.db.Query(ctx, getAllLatestSensorDataByTreeClusterID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SensorDatum{}
	for rows.Next() {
		var i SensorDatum
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Data,
			&i.SensorID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTreeClusterRegionsWithWateringPlanCount = `-- name: GetAllTreeClusterRegionsWithWateringPlanCount :many
SELECT 
    r.name AS name,
    COUNT(DISTINCT twp.watering_plan_id) AS watering_plan_count
FROM regions r
INNER JOIN tree_clusters tc ON r.id = tc.region_id
INNER JOIN tree_cluster_watering_plans twp ON tc.id = twp.tree_cluster_id
GROUP BY r.name
ORDER BY watering_plan_count DESC
`

type GetAllTreeClusterRegionsWithWateringPlanCountRow struct {
	Name              string
	WateringPlanCount int64
}

func (q *Queries) GetAllTreeClusterRegionsWithWateringPlanCount(ctx context.Context) ([]*GetAllTreeClusterRegionsWithWateringPlanCountRow, error) {
	rows, err := q.db.Query(ctx, getAllTreeClusterRegionsWithWateringPlanCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAllTreeClusterRegionsWithWateringPlanCountRow{}
	for rows.Next() {
		var i GetAllTreeClusterRegionsWithWateringPlanCountRow
		if err := rows.Scan(&i.Name, &i.WateringPlanCount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTreeClusters = `-- name: GetAllTreeClusters :many
SELECT tc.id, tc.created_at, tc.updated_at, tc.watering_status, tc.last_watered, tc.moisture_level, tc.address, tc.description, tc.archived, tc.soil_condition, tc.latitude, tc.longitude, tc.geometry, tc.region_id, tc.name, tc.provider, tc.additional_informations
FROM tree_clusters tc
         LEFT JOIN regions r ON r.id = tc.region_id
WHERE
    (COALESCE(array_length($3::TEXT[], 1), 0) = 0
        OR watering_status = ANY(($3::TEXT[])::watering_status[]))
  AND (COALESCE(array_length($4::TEXT[], 1), 0) = 0
    OR r.name = ANY($4::TEXT[]))
  AND (COALESCE($5, '') = '' OR provider = $5)
ORDER BY tc.name ASC
    LIMIT $1 OFFSET $2
`

type GetAllTreeClustersParams struct {
	Limit          int32
	Offset         int32
	WateringStatus []string
	Region         []string
	Provider       interface{}
}

func (q *Queries) GetAllTreeClusters(ctx context.Context, arg *GetAllTreeClustersParams) ([]*TreeCluster, error) {
	rows, err := q.db.Query(ctx, getAllTreeClusters,
		arg.Limit,
		arg.Offset,
		arg.WateringStatus,
		arg.Region,
		arg.Provider,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*TreeCluster{}
	for rows.Next() {
		var i TreeCluster
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.WateringStatus,
			&i.LastWatered,
			&i.MoistureLevel,
			&i.Address,
			&i.Description,
			&i.Archived,
			&i.SoilCondition,
			&i.Latitude,
			&i.Longitude,
			&i.Geometry,
			&i.RegionID,
			&i.Name,
			&i.Provider,
			&i.AdditionalInformations,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLinkedTreesByTreeClusterID = `-- name: GetLinkedTreesByTreeClusterID :many
SELECT trees.id, trees.created_at, trees.updated_at, trees.tree_cluster_id, trees.sensor_id, trees.planting_year, trees.species, trees.number, trees.latitude, trees.longitude, trees.watering_status, trees.geometry, trees.description, trees.provider, trees.additional_informations, trees.last_watered FROM trees JOIN tree_clusters ON trees.tree_cluster_id = tree_clusters.id WHERE tree_clusters.id = $1
`

func (q *Queries) GetLinkedTreesByTreeClusterID(ctx context.Context, id int32) ([]*Tree, error) {
	rows, err := q.db.Query(ctx, getLinkedTreesByTreeClusterID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Tree{}
	for rows.Next() {
		var i Tree
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TreeClusterID,
			&i.SensorID,
			&i.PlantingYear,
			&i.Species,
			&i.Number,
			&i.Latitude,
			&i.Longitude,
			&i.WateringStatus,
			&i.Geometry,
			&i.Description,
			&i.Provider,
			&i.AdditionalInformations,
			&i.LastWatered,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRegionByTreeClusterID = `-- name: GetRegionByTreeClusterID :one
SELECT regions.id, regions.name, regions.created_at, regions.updated_at, regions.geometry FROM regions JOIN tree_clusters ON regions.id = tree_clusters.region_id WHERE tree_clusters.id = $1
`

func (q *Queries) GetRegionByTreeClusterID(ctx context.Context, id int32) (*Region, error) {
	row := q.db.QueryRow(ctx, getRegionByTreeClusterID, id)
	var i Region
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Geometry,
	)
	return &i, err
}

const getTreeClusterByID = `-- name: GetTreeClusterByID :one
SELECT id, created_at, updated_at, watering_status, last_watered, moisture_level, address, description, archived, soil_condition, latitude, longitude, geometry, region_id, name, provider, additional_informations FROM tree_clusters WHERE id = $1
`

func (q *Queries) GetTreeClusterByID(ctx context.Context, id int32) (*TreeCluster, error) {
	row := q.db.QueryRow(ctx, getTreeClusterByID, id)
	var i TreeCluster
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.WateringStatus,
		&i.LastWatered,
		&i.MoistureLevel,
		&i.Address,
		&i.Description,
		&i.Archived,
		&i.SoilCondition,
		&i.Latitude,
		&i.Longitude,
		&i.Geometry,
		&i.RegionID,
		&i.Name,
		&i.Provider,
		&i.AdditionalInformations,
	)
	return &i, err
}

const getTreeClustersCount = `-- name: GetTreeClustersCount :one
SELECT COUNT(*)
FROM tree_clusters tc
         LEFT JOIN regions r ON r.id = tc.region_id
WHERE
    (COALESCE(array_length($1::TEXT[], 1), 0) = 0
        OR watering_status = ANY(($1::TEXT[])::watering_status[]))
  AND (COALESCE(array_length($2::TEXT[], 1), 0) = 0
    OR r.name = ANY($2::TEXT[]))
  AND (COALESCE($3, '') = '' OR provider = $3)
`

type GetTreeClustersCountParams struct {
	WateringStatus []string
	Region         []string
	Provider       interface{}
}

func (q *Queries) GetTreeClustersCount(ctx context.Context, arg *GetTreeClustersCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getTreeClustersCount, arg.WateringStatus, arg.Region, arg.Provider)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTreesClustersByIDs = `-- name: GetTreesClustersByIDs :many
SELECT id, created_at, updated_at, watering_status, last_watered, moisture_level, address, description, archived, soil_condition, latitude, longitude, geometry, region_id, name, provider, additional_informations FROM tree_clusters WHERE id = ANY($1::int[])
`

func (q *Queries) GetTreesClustersByIDs(ctx context.Context, dollar_1 []int32) ([]*TreeCluster, error) {
	rows, err := q.db.Query(ctx, getTreesClustersByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*TreeCluster{}
	for rows.Next() {
		var i TreeCluster
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.WateringStatus,
			&i.LastWatered,
			&i.MoistureLevel,
			&i.Address,
			&i.Description,
			&i.Archived,
			&i.SoilCondition,
			&i.Latitude,
			&i.Longitude,
			&i.Geometry,
			&i.RegionID,
			&i.Name,
			&i.Provider,
			&i.AdditionalInformations,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkTreesToTreeCluster = `-- name: LinkTreesToTreeCluster :exec
UPDATE trees SET tree_cluster_id = $2 WHERE id = ANY($1::int[])
`

type LinkTreesToTreeClusterParams struct {
	Column1       []int32
	TreeClusterID *int32
}

func (q *Queries) LinkTreesToTreeCluster(ctx context.Context, arg *LinkTreesToTreeClusterParams) error {
	_, err := q.db.Exec(ctx, linkTreesToTreeCluster, arg.Column1, arg.TreeClusterID)
	return err
}

const removeTreeClusterLocation = `-- name: RemoveTreeClusterLocation :exec
UPDATE tree_clusters SET
  latitude = NULL,
  longitude = NULL,
  geometry = NULL
WHERE id = $1
`

func (q *Queries) RemoveTreeClusterLocation(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, removeTreeClusterLocation, id)
	return err
}

const setTreeClusterLocation = `-- name: SetTreeClusterLocation :exec
UPDATE tree_clusters SET
  latitude = $2,
  longitude = $3,
  geometry = ST_SetSRID(ST_MakePoint($2, $3), 4326)
WHERE id = $1
`

type SetTreeClusterLocationParams struct {
	ID        int32
	Latitude  *float64
	Longitude *float64
}

func (q *Queries) SetTreeClusterLocation(ctx context.Context, arg *SetTreeClusterLocationParams) error {
	_, err := q.db.Exec(ctx, setTreeClusterLocation, arg.ID, arg.Latitude, arg.Longitude)
	return err
}

const updateTreeCluster = `-- name: UpdateTreeCluster :exec
UPDATE tree_clusters SET
  name = $2,
  region_id = $3,
  address = $4,
  description = $5,
  moisture_level = $6,
  watering_status = $7,
  soil_condition = $8,
  last_watered = $9,
  archived = $10,
  provider = $11,
  additional_informations = $12
WHERE id = $1
`

type UpdateTreeClusterParams struct {
	ID                     int32
	Name                   string
	RegionID               *int32
	Address                string
	Description            string
	MoistureLevel          float64
	WateringStatus         WateringStatus
	SoilCondition          TreeSoilCondition
	LastWatered            *time.Time
	Archived               bool
	Provider               *string
	AdditionalInformations []byte
}

func (q *Queries) UpdateTreeCluster(ctx context.Context, arg *UpdateTreeClusterParams) error {
	_, err := q.db.Exec(ctx, updateTreeCluster,
		arg.ID,
		arg.Name,
		arg.RegionID,
		arg.Address,
		arg.Description,
		arg.MoistureLevel,
		arg.WateringStatus,
		arg.SoilCondition,
		arg.LastWatered,
		arg.Archived,
		arg.Provider,
		arg.AdditionalInformations,
	)
	return err
}
