// Code generated by github.com/jmattheis/goverter, DO NOT EDIT.
//go:build !goverter

package generated

import (
	entities "github.com/green-ecolution/green-ecolution/backend/internal/entities"
	entities1 "github.com/green-ecolution/green-ecolution/backend/internal/server/http/entities"
	mapper "github.com/green-ecolution/green-ecolution/backend/internal/server/http/entities/mapper"
	utils "github.com/green-ecolution/green-ecolution/backend/internal/utils"
	"time"
)

type EvaluationHTTPMapperImpl struct{}

func (c *EvaluationHTTPMapperImpl) FromResponse(source *entities.Evaluation) *entities1.EvaluationResponse {
	var pEntitiesEvaluationResponse *entities1.EvaluationResponse
	if source != nil {
		var entitiesEvaluationResponse entities1.EvaluationResponse
		entitiesEvaluationResponse.TreeCount = (*source).TreeCount
		entitiesEvaluationResponse.TreeClusterCount = (*source).TreeClusterCount
		entitiesEvaluationResponse.SensorCount = (*source).SensorCount
		entitiesEvaluationResponse.WateringPlanCount = (*source).WateringPlanCount
		entitiesEvaluationResponse.TotalWaterConsumption = (*source).TotalWaterConsumption
		entitiesEvaluationResponse.UserWateringPlanCount = (*source).UserWateringPlanCount
		if (*source).VehicleEvaluation != nil {
			entitiesEvaluationResponse.VehicleEvaluation = make([]*entities1.VehicleEvaluationResponse, len((*source).VehicleEvaluation))
			for i := 0; i < len((*source).VehicleEvaluation); i++ {
				entitiesEvaluationResponse.VehicleEvaluation[i] = c.pEntitiesVehicleEvaluationToPEntitiesVehicleEvaluationResponse((*source).VehicleEvaluation[i])
			}
		}
		if (*source).RegionEvaluation != nil {
			entitiesEvaluationResponse.RegionEvaluation = make([]*entities1.RegionEvaluationResponse, len((*source).RegionEvaluation))
			for j := 0; j < len((*source).RegionEvaluation); j++ {
				entitiesEvaluationResponse.RegionEvaluation[j] = c.pEntitiesRegionEvaluationToPEntitiesRegionEvaluationResponse((*source).RegionEvaluation[j])
			}
		}
		pEntitiesEvaluationResponse = &entitiesEvaluationResponse
	}
	return pEntitiesEvaluationResponse
}
func (c *EvaluationHTTPMapperImpl) pEntitiesRegionEvaluationToPEntitiesRegionEvaluationResponse(source *entities.RegionEvaluation) *entities1.RegionEvaluationResponse {
	var pEntitiesRegionEvaluationResponse *entities1.RegionEvaluationResponse
	if source != nil {
		var entitiesRegionEvaluationResponse entities1.RegionEvaluationResponse
		entitiesRegionEvaluationResponse.Name = (*source).Name
		entitiesRegionEvaluationResponse.WateringPlanCount = (*source).WateringPlanCount
		pEntitiesRegionEvaluationResponse = &entitiesRegionEvaluationResponse
	}
	return pEntitiesRegionEvaluationResponse
}
func (c *EvaluationHTTPMapperImpl) pEntitiesVehicleEvaluationToPEntitiesVehicleEvaluationResponse(source *entities.VehicleEvaluation) *entities1.VehicleEvaluationResponse {
	var pEntitiesVehicleEvaluationResponse *entities1.VehicleEvaluationResponse
	if source != nil {
		var entitiesVehicleEvaluationResponse entities1.VehicleEvaluationResponse
		entitiesVehicleEvaluationResponse.NumberPlate = (*source).NumberPlate
		entitiesVehicleEvaluationResponse.WateringPlanCount = (*source).WateringPlanCount
		pEntitiesVehicleEvaluationResponse = &entitiesVehicleEvaluationResponse
	}
	return pEntitiesVehicleEvaluationResponse
}

type InfoHTTPMapperImpl struct{}

func (c *InfoHTTPMapperImpl) FromResponse(source *entities1.AppInfoResponse) *entities.App {
	var pEntitiesApp *entities.App
	if source != nil {
		var entitiesApp entities.App
		entitiesApp.Version = (*source).Version
		entitiesApp.VersionInfo = c.entitiesVersionInfoResponseToEntitiesVersionInfo((*source).VersionInfo)
		entitiesApp.GoVersion = (*source).GoVersion
		entitiesApp.BuildTime = utils.StringToTime((*source).BuildTime)
		entitiesApp.Git = c.entitiesGitResponseToEntitiesGit((*source).Git)
		entitiesApp.Server = c.entitiesServerResponseToEntitiesServer((*source).Server)
		entitiesApp.Map = c.entitiesMapResponseToEntitiesMap((*source).Map)
		entitiesApp.Services = c.entitiesServicesResponseToEntitiesServices((*source).Services)
		pEntitiesApp = &entitiesApp
	}
	return pEntitiesApp
}
func (c *InfoHTTPMapperImpl) ServerToResponse(source *entities.Server) *entities1.ServerResponse {
	var pEntitiesServerResponse *entities1.ServerResponse
	if source != nil {
		var entitiesServerResponse entities1.ServerResponse
		entitiesServerResponse.OS = (*source).OS
		entitiesServerResponse.Arch = (*source).Arch
		entitiesServerResponse.Hostname = (*source).Hostname
		entitiesServerResponse.URL = utils.NetURLToString((*source).URL)
		entitiesServerResponse.IP = utils.NetIPToString((*source).IP)
		entitiesServerResponse.Port = (*source).Port
		entitiesServerResponse.Interface = (*source).Interface
		entitiesServerResponse.Uptime = utils.TimeDurationToString((*source).Uptime)
		pEntitiesServerResponse = &entitiesServerResponse
	}
	return pEntitiesServerResponse
}
func (c *InfoHTTPMapperImpl) ServicesToResponse(source *entities.Services) *entities1.ServicesResponse {
	var pEntitiesServicesResponse *entities1.ServicesResponse
	if source != nil {
		var entitiesServicesResponse entities1.ServicesResponse
		entitiesServicesResponse.Items = mapper.MapServiceStatusItems((*source).Items)
		pEntitiesServicesResponse = &entitiesServicesResponse
	}
	return pEntitiesServicesResponse
}
func (c *InfoHTTPMapperImpl) ToResponse(source *entities.App) *entities1.AppInfoResponse {
	var pEntitiesAppInfoResponse *entities1.AppInfoResponse
	if source != nil {
		var entitiesAppInfoResponse entities1.AppInfoResponse
		entitiesAppInfoResponse.Version = (*source).Version
		entitiesAppInfoResponse.VersionInfo = c.entitiesVersionInfoToEntitiesVersionInfoResponse((*source).VersionInfo)
		entitiesAppInfoResponse.BuildTime = utils.TimeToString((*source).BuildTime)
		entitiesAppInfoResponse.GoVersion = (*source).GoVersion
		entitiesAppInfoResponse.Git = c.entitiesGitToEntitiesGitResponse((*source).Git)
		entitiesAppInfoResponse.Server = c.entitiesServerToEntitiesServerResponse((*source).Server)
		entitiesAppInfoResponse.Map = c.entitiesMapToEntitiesMapResponse((*source).Map)
		entitiesAppInfoResponse.Services = c.entitiesServicesToEntitiesServicesResponse((*source).Services)
		pEntitiesAppInfoResponse = &entitiesAppInfoResponse
	}
	return pEntitiesAppInfoResponse
}
func (c *InfoHTTPMapperImpl) entitiesGitResponseToEntitiesGit(source entities1.GitResponse) entities.Git {
	var entitiesGit entities.Git
	entitiesGit.Branch = source.Branch
	entitiesGit.Commit = source.Commit
	entitiesGit.Repository = utils.StringToURL(source.Repository)
	return entitiesGit
}
func (c *InfoHTTPMapperImpl) entitiesGitToEntitiesGitResponse(source entities.Git) entities1.GitResponse {
	var entitiesGitResponse entities1.GitResponse
	entitiesGitResponse.Branch = source.Branch
	entitiesGitResponse.Commit = source.Commit
	entitiesGitResponse.Repository = utils.NetURLToString(source.Repository)
	return entitiesGitResponse
}
func (c *InfoHTTPMapperImpl) entitiesMapResponseToEntitiesMap(source entities1.MapResponse) entities.Map {
	var entitiesMap entities.Map
	entitiesMap.Center = mapper.MapBbox(source.Center)
	entitiesMap.BBox = mapper.MapBbox(source.BBox)
	return entitiesMap
}
func (c *InfoHTTPMapperImpl) entitiesMapToEntitiesMapResponse(source entities.Map) entities1.MapResponse {
	var entitiesMapResponse entities1.MapResponse
	entitiesMapResponse.Center = mapper.MapBbox(source.Center)
	entitiesMapResponse.BBox = mapper.MapBbox(source.BBox)
	return entitiesMapResponse
}
func (c *InfoHTTPMapperImpl) entitiesServerResponseToEntitiesServer(source entities1.ServerResponse) entities.Server {
	var entitiesServer entities.Server
	entitiesServer.OS = source.OS
	entitiesServer.Arch = source.Arch
	entitiesServer.Hostname = source.Hostname
	entitiesServer.URL = utils.StringToURL(source.URL)
	entitiesServer.IP = utils.StringToNetIP(source.IP)
	entitiesServer.Port = source.Port
	entitiesServer.Interface = source.Interface
	entitiesServer.Uptime = utils.StringToDuration(source.Uptime)
	return entitiesServer
}
func (c *InfoHTTPMapperImpl) entitiesServerToEntitiesServerResponse(source entities.Server) entities1.ServerResponse {
	var entitiesServerResponse entities1.ServerResponse
	entitiesServerResponse.OS = source.OS
	entitiesServerResponse.Arch = source.Arch
	entitiesServerResponse.Hostname = source.Hostname
	entitiesServerResponse.URL = utils.NetURLToString(source.URL)
	entitiesServerResponse.IP = utils.NetIPToString(source.IP)
	entitiesServerResponse.Port = source.Port
	entitiesServerResponse.Interface = source.Interface
	entitiesServerResponse.Uptime = utils.TimeDurationToString(source.Uptime)
	return entitiesServerResponse
}
func (c *InfoHTTPMapperImpl) entitiesServicesResponseToEntitiesServices(source entities1.ServicesResponse) entities.Services {
	var entitiesServices entities.Services
	entitiesServices.Items = mapper.MapServiceStatusItemsReverse(source.Items)
	return entitiesServices
}
func (c *InfoHTTPMapperImpl) entitiesServicesToEntitiesServicesResponse(source entities.Services) entities1.ServicesResponse {
	var entitiesServicesResponse entities1.ServicesResponse
	entitiesServicesResponse.Items = mapper.MapServiceStatusItems(source.Items)
	return entitiesServicesResponse
}
func (c *InfoHTTPMapperImpl) entitiesVersionInfoResponseToEntitiesVersionInfo(source entities1.VersionInfoResponse) entities.VersionInfo {
	var entitiesVersionInfo entities.VersionInfo
	entitiesVersionInfo.Current = source.Current
	entitiesVersionInfo.Latest = source.Latest
	entitiesVersionInfo.UpdateAvailable = source.UpdateAvailable
	entitiesVersionInfo.IsDevelopment = source.IsDevelopment
	entitiesVersionInfo.IsStage = source.IsStage
	entitiesVersionInfo.ReleaseURL = source.ReleaseURL
	return entitiesVersionInfo
}
func (c *InfoHTTPMapperImpl) entitiesVersionInfoToEntitiesVersionInfoResponse(source entities.VersionInfo) entities1.VersionInfoResponse {
	var entitiesVersionInfoResponse entities1.VersionInfoResponse
	entitiesVersionInfoResponse.Current = source.Current
	entitiesVersionInfoResponse.Latest = source.Latest
	entitiesVersionInfoResponse.UpdateAvailable = source.UpdateAvailable
	entitiesVersionInfoResponse.IsDevelopment = source.IsDevelopment
	entitiesVersionInfoResponse.IsStage = source.IsStage
	entitiesVersionInfoResponse.ReleaseURL = source.ReleaseURL
	return entitiesVersionInfoResponse
}

type RegionHTTPMapperImpl struct{}

func (c *RegionHTTPMapperImpl) FromResponse(source *entities.Region) *entities1.RegionResponse {
	var pEntitiesRegionResponse *entities1.RegionResponse
	if source != nil {
		var entitiesRegionResponse entities1.RegionResponse
		entitiesRegionResponse.ID = (*source).ID
		entitiesRegionResponse.Name = (*source).Name
		pEntitiesRegionResponse = &entitiesRegionResponse
	}
	return pEntitiesRegionResponse
}

type SensorHTTPMapperImpl struct{}

func (c *SensorHTTPMapperImpl) FromDataResponse(source *entities.SensorData) *entities1.SensorDataResponse {
	return mapper.MapLatestDataToResponse(source)
}
func (c *SensorHTTPMapperImpl) FromResponse(source *entities.Sensor) *entities1.SensorResponse {
	var pEntitiesSensorResponse *entities1.SensorResponse
	if source != nil {
		var entitiesSensorResponse entities1.SensorResponse
		entitiesSensorResponse.ID = (*source).ID
		entitiesSensorResponse.CreatedAt = utils.TimeToTime((*source).CreatedAt)
		entitiesSensorResponse.UpdatedAt = utils.TimeToTime((*source).UpdatedAt)
		entitiesSensorResponse.Status = mapper.MapSensorStatus((*source).Status)
		entitiesSensorResponse.LatestData = mapper.MapLatestDataToResponse((*source).LatestData)
		entitiesSensorResponse.Latitude = (*source).Latitude
		entitiesSensorResponse.Longitude = (*source).Longitude
		entitiesSensorResponse.Provider = (*source).Provider
		entitiesSensorResponse.AdditionalInfo = utils.MapKeyValueInterface((*source).AdditionalInfo)
		pEntitiesSensorResponse = &entitiesSensorResponse
	}
	return pEntitiesSensorResponse
}
func (c *SensorHTTPMapperImpl) FromWatermarkResponse(source *entities.Watermark) *entities1.WatermarkResponse {
	var pEntitiesWatermarkResponse *entities1.WatermarkResponse
	if source != nil {
		var entitiesWatermarkResponse entities1.WatermarkResponse
		entitiesWatermarkResponse.Centibar = (*source).Centibar
		entitiesWatermarkResponse.Resistance = (*source).Resistance
		entitiesWatermarkResponse.Depth = (*source).Depth
		pEntitiesWatermarkResponse = &entitiesWatermarkResponse
	}
	return pEntitiesWatermarkResponse
}

type TreeClusterHTTPMapperImpl struct{}

func (c *TreeClusterHTTPMapperImpl) FromCreateRequest(source *entities1.TreeClusterCreateRequest) *entities.TreeClusterCreate {
	var pEntitiesTreeClusterCreate *entities.TreeClusterCreate
	if source != nil {
		var entitiesTreeClusterCreate entities.TreeClusterCreate
		entitiesTreeClusterCreate.Address = (*source).Address
		entitiesTreeClusterCreate.Description = (*source).Description
		entitiesTreeClusterCreate.Name = (*source).Name
		entitiesTreeClusterCreate.SoilCondition = mapper.MapSoilConditionReq((*source).SoilCondition)
		if (*source).TreeIDs != nil {
			entitiesTreeClusterCreate.TreeIDs = make([]*int32, len((*source).TreeIDs))
			for i := 0; i < len((*source).TreeIDs); i++ {
				if (*source).TreeIDs[i] != nil {
					xint32 := *(*source).TreeIDs[i]
					entitiesTreeClusterCreate.TreeIDs[i] = &xint32
				}
			}
		}
		entitiesTreeClusterCreate.Provider = (*source).Provider
		entitiesTreeClusterCreate.AdditionalInfo = utils.MapKeyValueInterface((*source).AdditionalInfo)
		pEntitiesTreeClusterCreate = &entitiesTreeClusterCreate
	}
	return pEntitiesTreeClusterCreate
}
func (c *TreeClusterHTTPMapperImpl) FromInListResponse(source *entities.TreeCluster) *entities1.TreeClusterInListResponse {
	var pEntitiesTreeClusterInListResponse *entities1.TreeClusterInListResponse
	if source != nil {
		var entitiesTreeClusterInListResponse entities1.TreeClusterInListResponse
		entitiesTreeClusterInListResponse.ID = (*source).ID
		entitiesTreeClusterInListResponse.CreatedAt = utils.TimeToTime((*source).CreatedAt)
		entitiesTreeClusterInListResponse.UpdatedAt = utils.TimeToTime((*source).UpdatedAt)
		entitiesTreeClusterInListResponse.WateringStatus = mapper.MapWateringStatus((*source).WateringStatus)
		entitiesTreeClusterInListResponse.LastWatered = utils.TimeToTimePtr((*source).LastWatered)
		entitiesTreeClusterInListResponse.MoistureLevel = (*source).MoistureLevel
		entitiesTreeClusterInListResponse.Region = c.pEntitiesRegionToPEntitiesRegionResponse((*source).Region)
		entitiesTreeClusterInListResponse.Address = (*source).Address
		entitiesTreeClusterInListResponse.Description = (*source).Description
		entitiesTreeClusterInListResponse.Archived = (*source).Archived
		if (*source).Latitude != nil {
			xfloat64 := *(*source).Latitude
			entitiesTreeClusterInListResponse.Latitude = &xfloat64
		}
		if (*source).Longitude != nil {
			xfloat642 := *(*source).Longitude
			entitiesTreeClusterInListResponse.Longitude = &xfloat642
		}
		entitiesTreeClusterInListResponse.TreeIDs = mapper.MapTreesToIDs((*source).Trees)
		entitiesTreeClusterInListResponse.SoilCondition = mapper.MapSoilCondition((*source).SoilCondition)
		entitiesTreeClusterInListResponse.Name = (*source).Name
		entitiesTreeClusterInListResponse.Provider = (*source).Provider
		entitiesTreeClusterInListResponse.AdditionalInfo = utils.MapKeyValueInterface((*source).AdditionalInfo)
		pEntitiesTreeClusterInListResponse = &entitiesTreeClusterInListResponse
	}
	return pEntitiesTreeClusterInListResponse
}
func (c *TreeClusterHTTPMapperImpl) FromResponse(source *entities.TreeCluster) *entities1.TreeClusterResponse {
	var pEntitiesTreeClusterResponse *entities1.TreeClusterResponse
	if source != nil {
		var entitiesTreeClusterResponse entities1.TreeClusterResponse
		entitiesTreeClusterResponse.ID = (*source).ID
		entitiesTreeClusterResponse.CreatedAt = utils.TimeToTime((*source).CreatedAt)
		entitiesTreeClusterResponse.UpdatedAt = utils.TimeToTime((*source).UpdatedAt)
		entitiesTreeClusterResponse.WateringStatus = mapper.MapWateringStatus((*source).WateringStatus)
		entitiesTreeClusterResponse.LastWatered = utils.TimeToTimePtr((*source).LastWatered)
		entitiesTreeClusterResponse.MoistureLevel = (*source).MoistureLevel
		entitiesTreeClusterResponse.Region = c.pEntitiesRegionToPEntitiesRegionResponse((*source).Region)
		entitiesTreeClusterResponse.Address = (*source).Address
		entitiesTreeClusterResponse.Description = (*source).Description
		entitiesTreeClusterResponse.Archived = (*source).Archived
		if (*source).Latitude != nil {
			xfloat64 := *(*source).Latitude
			entitiesTreeClusterResponse.Latitude = &xfloat64
		}
		if (*source).Longitude != nil {
			xfloat642 := *(*source).Longitude
			entitiesTreeClusterResponse.Longitude = &xfloat642
		}
		if (*source).Trees != nil {
			entitiesTreeClusterResponse.Trees = make([]*entities1.TreeResponse, len((*source).Trees))
			for i := 0; i < len((*source).Trees); i++ {
				entitiesTreeClusterResponse.Trees[i] = c.pEntitiesTreeToPEntitiesTreeResponse((*source).Trees[i])
			}
		}
		entitiesTreeClusterResponse.SoilCondition = mapper.MapSoilCondition((*source).SoilCondition)
		entitiesTreeClusterResponse.Name = (*source).Name
		entitiesTreeClusterResponse.Provider = (*source).Provider
		entitiesTreeClusterResponse.AdditionalInfo = utils.MapKeyValueInterface((*source).AdditionalInfo)
		pEntitiesTreeClusterResponse = &entitiesTreeClusterResponse
	}
	return pEntitiesTreeClusterResponse
}
func (c *TreeClusterHTTPMapperImpl) FromResponseList(source []*entities.TreeCluster) []*entities1.TreeClusterInListResponse {
	var pEntitiesTreeClusterInListResponseList []*entities1.TreeClusterInListResponse
	if source != nil {
		pEntitiesTreeClusterInListResponseList = make([]*entities1.TreeClusterInListResponse, len(source))
		for i := 0; i < len(source); i++ {
			pEntitiesTreeClusterInListResponseList[i] = c.FromInListResponse(source[i])
		}
	}
	return pEntitiesTreeClusterInListResponseList
}
func (c *TreeClusterHTTPMapperImpl) FromUpdateRequest(source *entities1.TreeClusterUpdateRequest) *entities.TreeClusterUpdate {
	var pEntitiesTreeClusterUpdate *entities.TreeClusterUpdate
	if source != nil {
		var entitiesTreeClusterUpdate entities.TreeClusterUpdate
		entitiesTreeClusterUpdate.Address = (*source).Address
		entitiesTreeClusterUpdate.Description = (*source).Description
		entitiesTreeClusterUpdate.SoilCondition = mapper.MapSoilConditionReq((*source).SoilCondition)
		if (*source).TreeIDs != nil {
			entitiesTreeClusterUpdate.TreeIDs = make([]*int32, len((*source).TreeIDs))
			for i := 0; i < len((*source).TreeIDs); i++ {
				if (*source).TreeIDs[i] != nil {
					xint32 := *(*source).TreeIDs[i]
					entitiesTreeClusterUpdate.TreeIDs[i] = &xint32
				}
			}
		}
		entitiesTreeClusterUpdate.Name = (*source).Name
		entitiesTreeClusterUpdate.Provider = (*source).Provider
		entitiesTreeClusterUpdate.AdditionalInfo = utils.MapKeyValueInterface((*source).AdditionalInfo)
		pEntitiesTreeClusterUpdate = &entitiesTreeClusterUpdate
	}
	return pEntitiesTreeClusterUpdate
}
func (c *TreeClusterHTTPMapperImpl) pEntitiesRegionToPEntitiesRegionResponse(source *entities.Region) *entities1.RegionResponse {
	var pEntitiesRegionResponse *entities1.RegionResponse
	if source != nil {
		var entitiesRegionResponse entities1.RegionResponse
		entitiesRegionResponse.ID = (*source).ID
		entitiesRegionResponse.Name = (*source).Name
		pEntitiesRegionResponse = &entitiesRegionResponse
	}
	return pEntitiesRegionResponse
}
func (c *TreeClusterHTTPMapperImpl) pEntitiesSensorDataToPEntitiesSensorDataResponse(source *entities.SensorData) *entities1.SensorDataResponse {
	var pEntitiesSensorDataResponse *entities1.SensorDataResponse
	if source != nil {
		var entitiesSensorDataResponse entities1.SensorDataResponse
		entitiesSensorDataResponse.CreatedAt = utils.TimeToTime((*source).CreatedAt)
		entitiesSensorDataResponse.UpdatedAt = utils.TimeToTime((*source).UpdatedAt)
		pEntitiesSensorDataResponse = &entitiesSensorDataResponse
	}
	return pEntitiesSensorDataResponse
}
func (c *TreeClusterHTTPMapperImpl) pEntitiesSensorToPEntitiesSensorResponse(source *entities.Sensor) *entities1.SensorResponse {
	var pEntitiesSensorResponse *entities1.SensorResponse
	if source != nil {
		var entitiesSensorResponse entities1.SensorResponse
		entitiesSensorResponse.ID = (*source).ID
		entitiesSensorResponse.CreatedAt = utils.TimeToTime((*source).CreatedAt)
		entitiesSensorResponse.UpdatedAt = utils.TimeToTime((*source).UpdatedAt)
		entitiesSensorResponse.Status = mapper.MapSensorStatus((*source).Status)
		entitiesSensorResponse.LatestData = c.pEntitiesSensorDataToPEntitiesSensorDataResponse((*source).LatestData)
		entitiesSensorResponse.Latitude = (*source).Latitude
		entitiesSensorResponse.Longitude = (*source).Longitude
		entitiesSensorResponse.Provider = (*source).Provider
		entitiesSensorResponse.AdditionalInfo = utils.MapKeyValueInterface((*source).AdditionalInfo)
		pEntitiesSensorResponse = &entitiesSensorResponse
	}
	return pEntitiesSensorResponse
}
func (c *TreeClusterHTTPMapperImpl) pEntitiesTreeToPEntitiesTreeResponse(source *entities.Tree) *entities1.TreeResponse {
	var pEntitiesTreeResponse *entities1.TreeResponse
	if source != nil {
		var entitiesTreeResponse entities1.TreeResponse
		entitiesTreeResponse.ID = (*source).ID
		entitiesTreeResponse.CreatedAt = utils.TimeToTime((*source).CreatedAt)
		entitiesTreeResponse.UpdatedAt = utils.TimeToTime((*source).UpdatedAt)
		entitiesTreeResponse.Sensor = c.pEntitiesSensorToPEntitiesSensorResponse((*source).Sensor)
		entitiesTreeResponse.LastWatered = utils.TimeToTimePtr((*source).LastWatered)
		entitiesTreeResponse.PlantingYear = (*source).PlantingYear
		entitiesTreeResponse.Species = (*source).Species
		entitiesTreeResponse.Number = (*source).Number
		entitiesTreeResponse.Latitude = (*source).Latitude
		entitiesTreeResponse.Longitude = (*source).Longitude
		entitiesTreeResponse.WateringStatus = mapper.MapWateringStatus((*source).WateringStatus)
		entitiesTreeResponse.Description = (*source).Description
		entitiesTreeResponse.Provider = (*source).Provider
		entitiesTreeResponse.AdditionalInfo = utils.MapKeyValueInterface((*source).AdditionalInfo)
		pEntitiesTreeResponse = &entitiesTreeResponse
	}
	return pEntitiesTreeResponse
}

type TreeHTTPMapperImpl struct{}

func (c *TreeHTTPMapperImpl) FromCreateRequest(source *entities1.TreeCreateRequest) *entities.TreeCreate {
	var pEntitiesTreeCreate *entities.TreeCreate
	if source != nil {
		var entitiesTreeCreate entities.TreeCreate
		if (*source).TreeClusterID != nil {
			xint32 := *(*source).TreeClusterID
			entitiesTreeCreate.TreeClusterID = &xint32
		}
		if (*source).SensorID != nil {
			xstring := *(*source).SensorID
			entitiesTreeCreate.SensorID = &xstring
		}
		entitiesTreeCreate.PlantingYear = (*source).PlantingYear
		entitiesTreeCreate.Species = (*source).Species
		entitiesTreeCreate.Number = (*source).Number
		entitiesTreeCreate.Latitude = (*source).Latitude
		entitiesTreeCreate.Longitude = (*source).Longitude
		entitiesTreeCreate.Description = (*source).Description
		entitiesTreeCreate.Provider = (*source).Provider
		entitiesTreeCreate.AdditionalInfo = utils.MapKeyValueInterface((*source).AdditionalInfo)
		pEntitiesTreeCreate = &entitiesTreeCreate
	}
	return pEntitiesTreeCreate
}
func (c *TreeHTTPMapperImpl) FromResponse(source *entities.Tree) *entities1.TreeResponse {
	var pEntitiesTreeResponse *entities1.TreeResponse
	if source != nil {
		var entitiesTreeResponse entities1.TreeResponse
		entitiesTreeResponse.ID = (*source).ID
		entitiesTreeResponse.CreatedAt = utils.TimeToTime((*source).CreatedAt)
		entitiesTreeResponse.UpdatedAt = utils.TimeToTime((*source).UpdatedAt)
		entitiesTreeResponse.TreeClusterID = mapper.MapTreeClusterToID((*source).TreeCluster)
		entitiesTreeResponse.LastWatered = c.pTimeTimeToPTimeTime((*source).LastWatered)
		entitiesTreeResponse.PlantingYear = (*source).PlantingYear
		entitiesTreeResponse.Species = (*source).Species
		entitiesTreeResponse.Number = (*source).Number
		entitiesTreeResponse.Latitude = (*source).Latitude
		entitiesTreeResponse.Longitude = (*source).Longitude
		entitiesTreeResponse.WateringStatus = mapper.MapWateringStatus((*source).WateringStatus)
		entitiesTreeResponse.Description = (*source).Description
		entitiesTreeResponse.Provider = (*source).Provider
		entitiesTreeResponse.AdditionalInfo = utils.MapKeyValueInterface((*source).AdditionalInfo)
		pEntitiesTreeResponse = &entitiesTreeResponse
	}
	return pEntitiesTreeResponse
}
func (c *TreeHTTPMapperImpl) FromResponseList(source []*entities.Tree) []*entities1.TreeResponse {
	var pEntitiesTreeResponseList []*entities1.TreeResponse
	if source != nil {
		pEntitiesTreeResponseList = make([]*entities1.TreeResponse, len(source))
		for i := 0; i < len(source); i++ {
			pEntitiesTreeResponseList[i] = c.FromResponse(source[i])
		}
	}
	return pEntitiesTreeResponseList
}
func (c *TreeHTTPMapperImpl) FromUpdateRequest(source *entities1.TreeUpdateRequest) *entities.TreeUpdate {
	var pEntitiesTreeUpdate *entities.TreeUpdate
	if source != nil {
		var entitiesTreeUpdate entities.TreeUpdate
		if (*source).TreeClusterID != nil {
			xint32 := *(*source).TreeClusterID
			entitiesTreeUpdate.TreeClusterID = &xint32
		}
		if (*source).SensorID != nil {
			xstring := *(*source).SensorID
			entitiesTreeUpdate.SensorID = &xstring
		}
		entitiesTreeUpdate.PlantingYear = (*source).PlantingYear
		entitiesTreeUpdate.Species = (*source).Species
		entitiesTreeUpdate.Number = (*source).Number
		entitiesTreeUpdate.Latitude = (*source).Latitude
		entitiesTreeUpdate.Longitude = (*source).Longitude
		entitiesTreeUpdate.Description = (*source).Description
		entitiesTreeUpdate.Provider = (*source).Provider
		entitiesTreeUpdate.AdditionalInfo = utils.MapKeyValueInterface((*source).AdditionalInfo)
		pEntitiesTreeUpdate = &entitiesTreeUpdate
	}
	return pEntitiesTreeUpdate
}
func (c *TreeHTTPMapperImpl) pTimeTimeToPTimeTime(source *time.Time) *time.Time {
	var pTimeTime *time.Time
	if source != nil {
		timeTime := utils.TimeToTime((*source))
		pTimeTime = &timeTime
	}
	return pTimeTime
}

type UserHTTPMapperImpl struct{}

func (c *UserHTTPMapperImpl) FromResponse(source *entities.User) *entities1.UserResponse {
	var pEntitiesUserResponse *entities1.UserResponse
	if source != nil {
		var entitiesUserResponse entities1.UserResponse
		entitiesUserResponse.ID = utils.UUIDToString((*source).ID)
		entitiesUserResponse.CreatedAt = utils.TimeToTime((*source).CreatedAt)
		entitiesUserResponse.Username = (*source).Username
		entitiesUserResponse.FirstName = (*source).FirstName
		entitiesUserResponse.LastName = (*source).LastName
		entitiesUserResponse.Email = (*source).Email
		entitiesUserResponse.EmployeeID = (*source).EmployeeID
		entitiesUserResponse.PhoneNumber = (*source).PhoneNumber
		entitiesUserResponse.EmailVerified = (*source).EmailVerified
		entitiesUserResponse.Avatar = utils.URLToString((*source).Avatar)
		if (*source).Roles != nil {
			entitiesUserResponse.Roles = make([]entities1.UserRole, len((*source).Roles))
			for i := 0; i < len((*source).Roles); i++ {
				entitiesUserResponse.Roles[i] = mapper.MapUserRoles((*source).Roles[i])
			}
		}
		if (*source).DrivingLicenses != nil {
			entitiesUserResponse.DrivingLicenses = make([]entities1.DrivingLicense, len((*source).DrivingLicenses))
			for j := 0; j < len((*source).DrivingLicenses); j++ {
				entitiesUserResponse.DrivingLicenses[j] = mapper.MapDrivingLicense((*source).DrivingLicenses[j])
			}
		}
		entitiesUserResponse.Status = mapper.MapUserStatus((*source).Status)
		pEntitiesUserResponse = &entitiesUserResponse
	}
	return pEntitiesUserResponse
}
func (c *UserHTTPMapperImpl) FromResponseList(source []*entities.User) []*entities1.UserResponse {
	var pEntitiesUserResponseList []*entities1.UserResponse
	if source != nil {
		pEntitiesUserResponseList = make([]*entities1.UserResponse, len(source))
		for i := 0; i < len(source); i++ {
			pEntitiesUserResponseList[i] = c.FromResponse(source[i])
		}
	}
	return pEntitiesUserResponseList
}

type VehicleHTTPMapperImpl struct{}

func (c *VehicleHTTPMapperImpl) FromCreateRequest(source *entities1.VehicleCreateRequest) *entities.VehicleCreate {
	var pEntitiesVehicleCreate *entities.VehicleCreate
	if source != nil {
		var entitiesVehicleCreate entities.VehicleCreate
		entitiesVehicleCreate.NumberPlate = (*source).NumberPlate
		entitiesVehicleCreate.Description = (*source).Description
		entitiesVehicleCreate.WaterCapacity = (*source).WaterCapacity
		entitiesVehicleCreate.Status = mapper.MapVehicleStatusReq((*source).Status)
		entitiesVehicleCreate.Type = mapper.MapVehicleTypeReq((*source).Type)
		entitiesVehicleCreate.Model = (*source).Model
		entitiesVehicleCreate.DrivingLicense = mapper.MapDrivingLicenseReq((*source).DrivingLicense)
		entitiesVehicleCreate.Height = (*source).Height
		entitiesVehicleCreate.Width = (*source).Width
		entitiesVehicleCreate.Length = (*source).Length
		entitiesVehicleCreate.Weight = (*source).Weight
		entitiesVehicleCreate.Provider = (*source).Provider
		entitiesVehicleCreate.AdditionalInfo = utils.MapKeyValueInterface((*source).AdditionalInfo)
		pEntitiesVehicleCreate = &entitiesVehicleCreate
	}
	return pEntitiesVehicleCreate
}
func (c *VehicleHTTPMapperImpl) FromResponse(source *entities.Vehicle) *entities1.VehicleResponse {
	var pEntitiesVehicleResponse *entities1.VehicleResponse
	if source != nil {
		var entitiesVehicleResponse entities1.VehicleResponse
		entitiesVehicleResponse.ID = (*source).ID
		entitiesVehicleResponse.CreatedAt = utils.TimeToTime((*source).CreatedAt)
		entitiesVehicleResponse.UpdatedAt = utils.TimeToTime((*source).UpdatedAt)
		entitiesVehicleResponse.ArchivedAt = utils.TimeToPtrTime((*source).ArchivedAt)
		entitiesVehicleResponse.NumberPlate = (*source).NumberPlate
		entitiesVehicleResponse.Description = (*source).Description
		entitiesVehicleResponse.WaterCapacity = (*source).WaterCapacity
		entitiesVehicleResponse.Status = mapper.MapVehicleStatus((*source).Status)
		entitiesVehicleResponse.Type = mapper.MapVehicleType((*source).Type)
		entitiesVehicleResponse.Model = (*source).Model
		entitiesVehicleResponse.DrivingLicense = mapper.MapDrivingLicense((*source).DrivingLicense)
		entitiesVehicleResponse.Height = (*source).Height
		entitiesVehicleResponse.Width = (*source).Width
		entitiesVehicleResponse.Length = (*source).Length
		entitiesVehicleResponse.Weight = (*source).Weight
		entitiesVehicleResponse.Provider = (*source).Provider
		entitiesVehicleResponse.AdditionalInfo = utils.MapKeyValueInterface((*source).AdditionalInfo)
		pEntitiesVehicleResponse = &entitiesVehicleResponse
	}
	return pEntitiesVehicleResponse
}
func (c *VehicleHTTPMapperImpl) FromResponseList(source []*entities.Vehicle) []*entities1.VehicleResponse {
	var pEntitiesVehicleResponseList []*entities1.VehicleResponse
	if source != nil {
		pEntitiesVehicleResponseList = make([]*entities1.VehicleResponse, len(source))
		for i := 0; i < len(source); i++ {
			pEntitiesVehicleResponseList[i] = c.FromResponse(source[i])
		}
	}
	return pEntitiesVehicleResponseList
}
func (c *VehicleHTTPMapperImpl) FromUpdateRequest(source *entities1.VehicleUpdateRequest) *entities.VehicleUpdate {
	var pEntitiesVehicleUpdate *entities.VehicleUpdate
	if source != nil {
		var entitiesVehicleUpdate entities.VehicleUpdate
		entitiesVehicleUpdate.NumberPlate = (*source).NumberPlate
		entitiesVehicleUpdate.Description = (*source).Description
		entitiesVehicleUpdate.WaterCapacity = (*source).WaterCapacity
		entitiesVehicleUpdate.Status = mapper.MapVehicleStatusReq((*source).Status)
		entitiesVehicleUpdate.Type = mapper.MapVehicleTypeReq((*source).Type)
		entitiesVehicleUpdate.Model = (*source).Model
		entitiesVehicleUpdate.DrivingLicense = mapper.MapDrivingLicenseReq((*source).DrivingLicense)
		entitiesVehicleUpdate.Height = (*source).Height
		entitiesVehicleUpdate.Width = (*source).Width
		entitiesVehicleUpdate.Length = (*source).Length
		entitiesVehicleUpdate.Weight = (*source).Weight
		entitiesVehicleUpdate.Provider = (*source).Provider
		entitiesVehicleUpdate.AdditionalInfo = utils.MapKeyValueInterface((*source).AdditionalInfo)
		pEntitiesVehicleUpdate = &entitiesVehicleUpdate
	}
	return pEntitiesVehicleUpdate
}

type WateringPlanHTTPMapperImpl struct{}

func (c *WateringPlanHTTPMapperImpl) FromCreateRequest(source *entities1.WateringPlanCreateRequest) *entities.WateringPlanCreate {
	var pEntitiesWateringPlanCreate *entities.WateringPlanCreate
	if source != nil {
		var entitiesWateringPlanCreate entities.WateringPlanCreate
		entitiesWateringPlanCreate.Date = utils.TimeToTime((*source).Date)
		entitiesWateringPlanCreate.Description = (*source).Description
		if (*source).TreeClusterIDs != nil {
			entitiesWateringPlanCreate.TreeClusterIDs = make([]*int32, len((*source).TreeClusterIDs))
			for i := 0; i < len((*source).TreeClusterIDs); i++ {
				if (*source).TreeClusterIDs[i] != nil {
					xint32 := *(*source).TreeClusterIDs[i]
					entitiesWateringPlanCreate.TreeClusterIDs[i] = &xint32
				}
			}
		}
		if (*source).TransporterID != nil {
			xint322 := *(*source).TransporterID
			entitiesWateringPlanCreate.TransporterID = &xint322
		}
		if (*source).TrailerID != nil {
			xint323 := *(*source).TrailerID
			entitiesWateringPlanCreate.TrailerID = &xint323
		}
		entitiesWateringPlanCreate.UserIDs = mapper.MapUUIDReq((*source).UserIDs)
		entitiesWateringPlanCreate.Provider = (*source).Provider
		entitiesWateringPlanCreate.AdditionalInfo = utils.MapKeyValueInterface((*source).AdditionalInfo)
		pEntitiesWateringPlanCreate = &entitiesWateringPlanCreate
	}
	return pEntitiesWateringPlanCreate
}
func (c *WateringPlanHTTPMapperImpl) FromInListResponse(source *entities.WateringPlan) *entities1.WateringPlanInListResponse {
	var pEntitiesWateringPlanInListResponse *entities1.WateringPlanInListResponse
	if source != nil {
		var entitiesWateringPlanInListResponse entities1.WateringPlanInListResponse
		entitiesWateringPlanInListResponse.ID = (*source).ID
		entitiesWateringPlanInListResponse.CreatedAt = utils.TimeToTime((*source).CreatedAt)
		entitiesWateringPlanInListResponse.UpdatedAt = utils.TimeToTime((*source).UpdatedAt)
		entitiesWateringPlanInListResponse.Date = utils.TimeToTime((*source).Date)
		entitiesWateringPlanInListResponse.Description = (*source).Description
		entitiesWateringPlanInListResponse.Status = mapper.MapWateringPlanStatus((*source).Status)
		if (*source).Distance != nil {
			xfloat64 := *(*source).Distance
			entitiesWateringPlanInListResponse.Distance = &xfloat64
		}
		if (*source).TotalWaterRequired != nil {
			xfloat642 := *(*source).TotalWaterRequired
			entitiesWateringPlanInListResponse.TotalWaterRequired = &xfloat642
		}
		entitiesWateringPlanInListResponse.UserIDs = mapper.MapUUIDs((*source).UserIDs)
		if (*source).TreeClusters != nil {
			entitiesWateringPlanInListResponse.TreeClusters = make([]*entities1.TreeClusterInListResponse, len((*source).TreeClusters))
			for i := 0; i < len((*source).TreeClusters); i++ {
				entitiesWateringPlanInListResponse.TreeClusters[i] = c.FromTreeClusterInListResponse((*source).TreeClusters[i])
			}
		}
		entitiesWateringPlanInListResponse.Transporter = c.pEntitiesVehicleToPEntitiesVehicleResponse((*source).Transporter)
		entitiesWateringPlanInListResponse.Trailer = c.pEntitiesVehicleToPEntitiesVehicleResponse((*source).Trailer)
		entitiesWateringPlanInListResponse.CancellationNote = (*source).CancellationNote
		entitiesWateringPlanInListResponse.Provider = (*source).Provider
		entitiesWateringPlanInListResponse.AdditionalInfo = utils.MapKeyValueInterface((*source).AdditionalInfo)
		pEntitiesWateringPlanInListResponse = &entitiesWateringPlanInListResponse
	}
	return pEntitiesWateringPlanInListResponse
}
func (c *WateringPlanHTTPMapperImpl) FromResponse(source *entities.WateringPlan) *entities1.WateringPlanResponse {
	var pEntitiesWateringPlanResponse *entities1.WateringPlanResponse
	if source != nil {
		var entitiesWateringPlanResponse entities1.WateringPlanResponse
		entitiesWateringPlanResponse.ID = (*source).ID
		entitiesWateringPlanResponse.CreatedAt = utils.TimeToTime((*source).CreatedAt)
		entitiesWateringPlanResponse.UpdatedAt = utils.TimeToTime((*source).UpdatedAt)
		entitiesWateringPlanResponse.Date = utils.TimeToTime((*source).Date)
		entitiesWateringPlanResponse.Description = (*source).Description
		entitiesWateringPlanResponse.Status = mapper.MapWateringPlanStatus((*source).Status)
		if (*source).Distance != nil {
			xfloat64 := *(*source).Distance
			entitiesWateringPlanResponse.Distance = &xfloat64
		}
		if (*source).TotalWaterRequired != nil {
			xfloat642 := *(*source).TotalWaterRequired
			entitiesWateringPlanResponse.TotalWaterRequired = &xfloat642
		}
		entitiesWateringPlanResponse.UserIDs = mapper.MapUUIDs((*source).UserIDs)
		if (*source).TreeClusters != nil {
			entitiesWateringPlanResponse.TreeClusters = make([]*entities1.TreeClusterInListResponse, len((*source).TreeClusters))
			for i := 0; i < len((*source).TreeClusters); i++ {
				entitiesWateringPlanResponse.TreeClusters[i] = c.FromTreeClusterInListResponse((*source).TreeClusters[i])
			}
		}
		entitiesWateringPlanResponse.Transporter = c.pEntitiesVehicleToPEntitiesVehicleResponse((*source).Transporter)
		entitiesWateringPlanResponse.Trailer = c.pEntitiesVehicleToPEntitiesVehicleResponse((*source).Trailer)
		entitiesWateringPlanResponse.CancellationNote = (*source).CancellationNote
		if (*source).Evaluation != nil {
			entitiesWateringPlanResponse.Evaluation = make([]*entities1.EvaluationValue, len((*source).Evaluation))
			for j := 0; j < len((*source).Evaluation); j++ {
				entitiesWateringPlanResponse.Evaluation[j] = c.pEntitiesEvaluationValueToPEntitiesEvaluationValue((*source).Evaluation[j])
			}
		}
		entitiesWateringPlanResponse.GpxURL = (*source).GpxURL
		entitiesWateringPlanResponse.Duration = utils.DurationToPtrFloat64((*source).Duration)
		entitiesWateringPlanResponse.RefillCount = (*source).RefillCount
		entitiesWateringPlanResponse.Provider = (*source).Provider
		entitiesWateringPlanResponse.AdditionalInfo = utils.MapKeyValueInterface((*source).AdditionalInfo)
		pEntitiesWateringPlanResponse = &entitiesWateringPlanResponse
	}
	return pEntitiesWateringPlanResponse
}
func (c *WateringPlanHTTPMapperImpl) FromResponseList(source []*entities.WateringPlan) []*entities1.WateringPlanResponse {
	var pEntitiesWateringPlanResponseList []*entities1.WateringPlanResponse
	if source != nil {
		pEntitiesWateringPlanResponseList = make([]*entities1.WateringPlanResponse, len(source))
		for i := 0; i < len(source); i++ {
			pEntitiesWateringPlanResponseList[i] = c.FromResponse(source[i])
		}
	}
	return pEntitiesWateringPlanResponseList
}
func (c *WateringPlanHTTPMapperImpl) FromTreeClusterInListResponse(source *entities.TreeCluster) *entities1.TreeClusterInListResponse {
	var pEntitiesTreeClusterInListResponse *entities1.TreeClusterInListResponse
	if source != nil {
		var entitiesTreeClusterInListResponse entities1.TreeClusterInListResponse
		entitiesTreeClusterInListResponse.ID = (*source).ID
		entitiesTreeClusterInListResponse.CreatedAt = utils.TimeToTime((*source).CreatedAt)
		entitiesTreeClusterInListResponse.UpdatedAt = utils.TimeToTime((*source).UpdatedAt)
		entitiesTreeClusterInListResponse.WateringStatus = mapper.MapWateringStatus((*source).WateringStatus)
		entitiesTreeClusterInListResponse.LastWatered = utils.TimeToTimePtr((*source).LastWatered)
		entitiesTreeClusterInListResponse.MoistureLevel = (*source).MoistureLevel
		entitiesTreeClusterInListResponse.Region = c.pEntitiesRegionToPEntitiesRegionResponse2((*source).Region)
		entitiesTreeClusterInListResponse.Address = (*source).Address
		entitiesTreeClusterInListResponse.Description = (*source).Description
		entitiesTreeClusterInListResponse.Archived = (*source).Archived
		if (*source).Latitude != nil {
			xfloat64 := *(*source).Latitude
			entitiesTreeClusterInListResponse.Latitude = &xfloat64
		}
		if (*source).Longitude != nil {
			xfloat642 := *(*source).Longitude
			entitiesTreeClusterInListResponse.Longitude = &xfloat642
		}
		entitiesTreeClusterInListResponse.TreeIDs = mapper.MapTreesToIDs((*source).Trees)
		entitiesTreeClusterInListResponse.SoilCondition = mapper.MapSoilCondition((*source).SoilCondition)
		entitiesTreeClusterInListResponse.Name = (*source).Name
		entitiesTreeClusterInListResponse.Provider = (*source).Provider
		entitiesTreeClusterInListResponse.AdditionalInfo = utils.MapKeyValueInterface((*source).AdditionalInfo)
		pEntitiesTreeClusterInListResponse = &entitiesTreeClusterInListResponse
	}
	return pEntitiesTreeClusterInListResponse
}
func (c *WateringPlanHTTPMapperImpl) FromUpdateRequest(source *entities1.WateringPlanUpdateRequest) *entities.WateringPlanUpdate {
	var pEntitiesWateringPlanUpdate *entities.WateringPlanUpdate
	if source != nil {
		var entitiesWateringPlanUpdate entities.WateringPlanUpdate
		entitiesWateringPlanUpdate.Date = utils.TimeToTime((*source).Date)
		entitiesWateringPlanUpdate.Description = (*source).Description
		if (*source).TreeClusterIDs != nil {
			entitiesWateringPlanUpdate.TreeClusterIDs = make([]*int32, len((*source).TreeClusterIDs))
			for i := 0; i < len((*source).TreeClusterIDs); i++ {
				if (*source).TreeClusterIDs[i] != nil {
					xint32 := *(*source).TreeClusterIDs[i]
					entitiesWateringPlanUpdate.TreeClusterIDs[i] = &xint32
				}
			}
		}
		if (*source).TransporterID != nil {
			xint322 := *(*source).TransporterID
			entitiesWateringPlanUpdate.TransporterID = &xint322
		}
		if (*source).TrailerID != nil {
			xint323 := *(*source).TrailerID
			entitiesWateringPlanUpdate.TrailerID = &xint323
		}
		entitiesWateringPlanUpdate.CancellationNote = (*source).CancellationNote
		entitiesWateringPlanUpdate.Status = mapper.MapWateringPlanStatusReq((*source).Status)
		if (*source).Evaluation != nil {
			entitiesWateringPlanUpdate.Evaluation = make([]*entities.EvaluationValue, len((*source).Evaluation))
			for j := 0; j < len((*source).Evaluation); j++ {
				entitiesWateringPlanUpdate.Evaluation[j] = c.pEntitiesEvaluationValueToPEntitiesEvaluationValue2((*source).Evaluation[j])
			}
		}
		entitiesWateringPlanUpdate.UserIDs = mapper.MapUUIDReq((*source).UserIDs)
		entitiesWateringPlanUpdate.Provider = (*source).Provider
		entitiesWateringPlanUpdate.AdditionalInfo = utils.MapKeyValueInterface((*source).AdditionalInfo)
		pEntitiesWateringPlanUpdate = &entitiesWateringPlanUpdate
	}
	return pEntitiesWateringPlanUpdate
}
func (c *WateringPlanHTTPMapperImpl) pEntitiesEvaluationValueToPEntitiesEvaluationValue(source *entities.EvaluationValue) *entities1.EvaluationValue {
	var pEntitiesEvaluationValue *entities1.EvaluationValue
	if source != nil {
		var entitiesEvaluationValue entities1.EvaluationValue
		entitiesEvaluationValue.WateringPlanID = (*source).WateringPlanID
		entitiesEvaluationValue.TreeClusterID = (*source).TreeClusterID
		if (*source).ConsumedWater != nil {
			xfloat64 := *(*source).ConsumedWater
			entitiesEvaluationValue.ConsumedWater = &xfloat64
		}
		pEntitiesEvaluationValue = &entitiesEvaluationValue
	}
	return pEntitiesEvaluationValue
}
func (c *WateringPlanHTTPMapperImpl) pEntitiesEvaluationValueToPEntitiesEvaluationValue2(source *entities1.EvaluationValue) *entities.EvaluationValue {
	var pEntitiesEvaluationValue *entities.EvaluationValue
	if source != nil {
		var entitiesEvaluationValue entities.EvaluationValue
		entitiesEvaluationValue.WateringPlanID = (*source).WateringPlanID
		entitiesEvaluationValue.TreeClusterID = (*source).TreeClusterID
		if (*source).ConsumedWater != nil {
			xfloat64 := *(*source).ConsumedWater
			entitiesEvaluationValue.ConsumedWater = &xfloat64
		}
		pEntitiesEvaluationValue = &entitiesEvaluationValue
	}
	return pEntitiesEvaluationValue
}
func (c *WateringPlanHTTPMapperImpl) pEntitiesRegionToPEntitiesRegionResponse2(source *entities.Region) *entities1.RegionResponse {
	var pEntitiesRegionResponse *entities1.RegionResponse
	if source != nil {
		var entitiesRegionResponse entities1.RegionResponse
		entitiesRegionResponse.ID = (*source).ID
		entitiesRegionResponse.Name = (*source).Name
		pEntitiesRegionResponse = &entitiesRegionResponse
	}
	return pEntitiesRegionResponse
}
func (c *WateringPlanHTTPMapperImpl) pEntitiesVehicleToPEntitiesVehicleResponse(source *entities.Vehicle) *entities1.VehicleResponse {
	var pEntitiesVehicleResponse *entities1.VehicleResponse
	if source != nil {
		var entitiesVehicleResponse entities1.VehicleResponse
		entitiesVehicleResponse.ID = (*source).ID
		entitiesVehicleResponse.CreatedAt = utils.TimeToTime((*source).CreatedAt)
		entitiesVehicleResponse.UpdatedAt = utils.TimeToTime((*source).UpdatedAt)
		entitiesVehicleResponse.ArchivedAt = utils.TimeToPtrTime((*source).ArchivedAt)
		entitiesVehicleResponse.NumberPlate = (*source).NumberPlate
		entitiesVehicleResponse.Description = (*source).Description
		entitiesVehicleResponse.WaterCapacity = (*source).WaterCapacity
		entitiesVehicleResponse.Status = mapper.MapVehicleStatus((*source).Status)
		entitiesVehicleResponse.Type = mapper.MapVehicleType((*source).Type)
		entitiesVehicleResponse.Model = (*source).Model
		entitiesVehicleResponse.DrivingLicense = mapper.MapDrivingLicense((*source).DrivingLicense)
		entitiesVehicleResponse.Height = (*source).Height
		entitiesVehicleResponse.Width = (*source).Width
		entitiesVehicleResponse.Length = (*source).Length
		entitiesVehicleResponse.Weight = (*source).Weight
		entitiesVehicleResponse.Provider = (*source).Provider
		entitiesVehicleResponse.AdditionalInfo = utils.MapKeyValueInterface((*source).AdditionalInfo)
		pEntitiesVehicleResponse = &entitiesVehicleResponse
	}
	return pEntitiesVehicleResponse
}
